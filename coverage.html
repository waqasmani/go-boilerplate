
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/waqasmani/go-boilerplate/cmd/api/docs/docs.go (0.0%)</option>
				
				<option value="file1">github.com/waqasmani/go-boilerplate/cmd/api/main.go (0.0%)</option>
				
				<option value="file2">github.com/waqasmani/go-boilerplate/cmd/migrate/main.go (0.0%)</option>
				
				<option value="file3">github.com/waqasmani/go-boilerplate/internal/app/container.go (32.9%)</option>
				
				<option value="file4">github.com/waqasmani/go-boilerplate/internal/app/router.go (97.3%)</option>
				
				<option value="file5">github.com/waqasmani/go-boilerplate/internal/app/server.go (26.3%)</option>
				
				<option value="file6">github.com/waqasmani/go-boilerplate/internal/config/config.go (88.3%)</option>
				
				<option value="file7">github.com/waqasmani/go-boilerplate/internal/infrastructure/database/circuit_breaker.go (0.0%)</option>
				
				<option value="file8">github.com/waqasmani/go-boilerplate/internal/infrastructure/database/errors/errors.go (59.5%)</option>
				
				<option value="file9">github.com/waqasmani/go-boilerplate/internal/infrastructure/database/errors/retry.go (84.7%)</option>
				
				<option value="file10">github.com/waqasmani/go-boilerplate/internal/infrastructure/database/mariadb.go (64.3%)</option>
				
				<option value="file11">github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware/auth_middleware.go (0.0%)</option>
				
				<option value="file12">github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware/security_middlewares.go (0.0%)</option>
				
				<option value="file13">github.com/waqasmani/go-boilerplate/internal/infrastructure/migrations/config.go (0.0%)</option>
				
				<option value="file14">github.com/waqasmani/go-boilerplate/internal/infrastructure/observability/audit.go (11.1%)</option>
				
				<option value="file15">github.com/waqasmani/go-boilerplate/internal/infrastructure/observability/logger.go (71.1%)</option>
				
				<option value="file16">github.com/waqasmani/go-boilerplate/internal/infrastructure/observability/metrics.go (93.0%)</option>
				
				<option value="file17">github.com/waqasmani/go-boilerplate/internal/infrastructure/observability/tracing.go (100.0%)</option>
				
				<option value="file18">github.com/waqasmani/go-boilerplate/internal/infrastructure/security/jwt.go (82.1%)</option>
				
				<option value="file19">github.com/waqasmani/go-boilerplate/internal/infrastructure/security/password.go (65.0%)</option>
				
				<option value="file20">github.com/waqasmani/go-boilerplate/internal/infrastructure/security/rate_limiter.go (42.0%)</option>
				
				<option value="file21">github.com/waqasmani/go-boilerplate/internal/infrastructure/security/security.go (0.0%)</option>
				
				<option value="file22">github.com/waqasmani/go-boilerplate/internal/modules/attendance/attendance.errors.go (100.0%)</option>
				
				<option value="file23">github.com/waqasmani/go-boilerplate/internal/modules/attendance/attendance.handler.go (79.5%)</option>
				
				<option value="file24">github.com/waqasmani/go-boilerplate/internal/modules/attendance/attendance.routes.go (100.0%)</option>
				
				<option value="file25">github.com/waqasmani/go-boilerplate/internal/modules/attendance/attendance.scheduler.go (83.3%)</option>
				
				<option value="file26">github.com/waqasmani/go-boilerplate/internal/modules/attendance/attendance.service.go (95.9%)</option>
				
				<option value="file27">github.com/waqasmani/go-boilerplate/internal/modules/auth/auth.handler.go (82.4%)</option>
				
				<option value="file28">github.com/waqasmani/go-boilerplate/internal/modules/auth/auth.routes.go (100.0%)</option>
				
				<option value="file29">github.com/waqasmani/go-boilerplate/internal/modules/auth/auth.service.go (85.1%)</option>
				
				<option value="file30">github.com/waqasmani/go-boilerplate/internal/modules/auth/auth.test_setup.go (100.0%)</option>
				
				<option value="file31">github.com/waqasmani/go-boilerplate/internal/modules/health/health.handler.go (0.0%)</option>
				
				<option value="file32">github.com/waqasmani/go-boilerplate/internal/modules/health/health.routes.go (0.0%)</option>
				
				<option value="file33">github.com/waqasmani/go-boilerplate/internal/modules/users/users.handler.go (0.0%)</option>
				
				<option value="file34">github.com/waqasmani/go-boilerplate/internal/modules/users/users.routes.go (0.0%)</option>
				
				<option value="file35">github.com/waqasmani/go-boilerplate/internal/modules/users/users.service.go (0.0%)</option>
				
				<option value="file36">github.com/waqasmani/go-boilerplate/internal/shared/errors/errors.go (55.0%)</option>
				
				<option value="file37">github.com/waqasmani/go-boilerplate/internal/shared/utils/response.go (66.7%)</option>
				
				<option value="file38">github.com/waqasmani/go-boilerplate/internal/shared/validator/validator.go (62.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/alive": {
            "get": {
                "description": "Check if application is alive",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Get liveness status",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/attendance": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieves attendance records with pagination and filters",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Attendance"
                ],
                "summary": "List attendance records",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID filter",
                        "name": "user_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Start date (RFC3339)",
                        "name": "from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "End date (RFC3339)",
                        "name": "to",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "present",
                            "on_leave",
                            "absent",
                            "manual"
                        ],
                        "type": "string",
                        "description": "Status filter",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Shift ID filter",
                        "name": "shift_id",
                        "in": "query"
                    },
                    {
                        "maximum": 100,
                        "minimum": 1,
                        "type": "integer",
                        "default": 20,
                        "description": "Page size",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/ListAttendanceResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/attendance/check-in": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Records employee check-in with optional geolocation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Attendance"
                ],
                "summary": "Check in to work",
                "parameters": [
                    {
                        "description": "Check-in details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/CheckInRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/AttendanceResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/attendance/check-out": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Records employee check-out and calculates duration",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Attendance"
                ],
                "summary": "Check out from work",
                "parameters": [
                    {
                        "description": "Check-out details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/CheckOutRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/AttendanceResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/attendance/leave-balance": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieves current leave balance for authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Attendance"
                ],
                "summary": "Get leave balance",
                "parameters": [
                    {
                        "enum": [
                            "sick",
                            "vacation",
                            "personal"
                        ],
                        "type": "string",
                        "description": "Leave type",
                        "name": "leave_type",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/LeaveBalanceResponse"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/attendance/time-off": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Employee submits a time off request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Time Off"
                ],
                "summary": "Request time off",
                "parameters": [
                    {
                        "description": "Time off request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/TimeOffRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/TimeOffResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/attendance/time-off/{id}/approve": {
            "patch": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Manager approves a pending time off request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Time Off"
                ],
                "summary": "Approve time off (Manager only)",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Time off request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Review note",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ReviewTimeOffRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/attendance/time-off/{id}/reject": {
            "patch": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Manager rejects a pending time off request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Time Off"
                ],
                "summary": "Reject time off (Manager only)",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Time off request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Review note",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ReviewTimeOffRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/attendance/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieves a single attendance record by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Attendance"
                ],
                "summary": "Get attendance by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Attendance ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/AttendanceResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/attendance/{id}/manual": {
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Allows managers to manually create or edit attendance records",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Attendance"
                ],
                "summary": "Manually edit attendance (Admin/Manager only)",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Attendance ID (0 for new)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Manual attendance data",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ManualAttendanceRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/AttendanceResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "Authenticate user and return access token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Login to get access token",
                "parameters": [
                    {
                        "description": "User credentials",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_modules_auth.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_modules_auth.AuthResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Invalidate refresh token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Logout user",
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/auth/me": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get information about the currently authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Get current user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_modules_auth.UserResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "security": [
                    {
                        "CsrfToken": []
                    }
                ],
                "description": "Get a new access token using refresh token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Refresh access token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_modules_auth.AuthResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Create a new user account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User registration details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_modules_auth.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_modules_auth.UserResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/health": {
            "get": {
                "description": "Get comprehensive health status of the application",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Get health status",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_modules_health.HealthResponse"
                        }
                    }
                }
            }
        },
        "/ready": {
            "get": {
                "description": "Check if application is ready to serve traffic",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Get readiness status",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_modules_health.HealthResponse"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/internal_modules_health.HealthResponse"
                        }
                    }
                }
            }
        },
        "/reports/daily-summary": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieves attendance summary for a specific date",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reports"
                ],
                "summary": "Get daily attendance summary",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Date (YYYY-MM-DD format)",
                        "name": "date",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/DailySummaryResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/reports/employee/{id}/export": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Exports timesheet data for an employee for a specific period",
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "Reports"
                ],
                "summary": "Export employee timesheet",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Employee ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Start date (YYYY-MM-DD format)",
                        "name": "start_date",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "End date (YYYY-MM-DD format)",
                        "name": "end_date",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Timesheet CSV file",
                        "schema": {
                            "type": "file"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/users": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get paginated list of users (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "List users",
                "parameters": [
                    {
                        "maximum": 100,
                        "minimum": 1,
                        "type": "integer",
                        "default": 20,
                        "description": "Page size",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_modules_users.ListUsersResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Create a new user (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Create user",
                "parameters": [
                    {
                        "description": "User creation details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_modules_users.CreateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_modules_users.UserResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/users/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get user details by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Get user by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_modules_users.UserResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Update user's first and last name",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Update user profile",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated user details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_modules_users.UpdateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_modules_users.UserResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Soft delete a user (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Delete user",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        },
        "/users/{id}/password": {
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Change user's password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Update user password",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Password update details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_modules_users.UpdatePasswordRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "object",
                                            "additionalProperties": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.Response"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "AttendanceResponse": {
            "description": "Attendance record response",
            "type": "object",
            "properties": {
                "check_in_at": {
                    "type": "string"
                },
                "check_in_latitude": {
                    "type": "number"
                },
                "check_in_longitude": {
                    "type": "number"
                },
                "check_out_at": {
                    "type": "string"
                },
                "check_out_latitude": {
                    "type": "number"
                },
                "check_out_longitude": {
                    "type": "number"
                },
                "created_at": {
                    "type": "string"
                },
                "duration_seconds": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "is_early_leave": {
                    "type": "boolean"
                },
                "is_late": {
                    "type": "boolean"
                },
                "overtime_seconds": {
                    "type": "integer"
                },
                "shift_id": {
                    "type": "integer"
                },
                "status": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "CheckInRequest": {
            "description": "Check-in request with optional geolocation",
            "type": "object",
            "properties": {
                "client_timestamp": {
                    "type": "string"
                },
                "latitude": {
                    "type": "number"
                },
                "longitude": {
                    "type": "number"
                }
            }
        },
        "CheckOutRequest": {
            "description": "Check-out request with optional geolocation",
            "type": "object",
            "properties": {
                "attendance_id": {
                    "description": "Optional: specify which session to close",
                    "type": "integer"
                },
                "client_timestamp": {
                    "type": "string"
                },
                "latitude": {
                    "type": "number"
                },
                "longitude": {
                    "type": "number"
                }
            }
        },
        "DailySummaryResponse": {
            "type": "object",
            "properties": {
                "absent_count": {
                    "type": "integer"
                },
                "date": {
                    "type": "string"
                },
                "late_count": {
                    "type": "integer"
                },
                "on_leave_count": {
                    "type": "integer"
                },
                "present_count": {
                    "type": "integer"
                },
                "total_attendance": {
                    "type": "integer"
                },
                "total_hours": {
                    "type": "number"
                },
                "total_overtime_hours": {
                    "type": "number"
                }
            }
        },
        "LeaveBalanceResponse": {
            "type": "object",
            "properties": {
                "accrued_days": {
                    "type": "number"
                },
                "available_days": {
                    "type": "number"
                },
                "carryover_days": {
                    "type": "number"
                },
                "leave_type": {
                    "type": "string"
                },
                "used_days": {
                    "type": "number"
                },
                "year": {
                    "type": "integer"
                }
            }
        },
        "ListAttendanceResponse": {
            "type": "object",
            "properties": {
                "limit": {
                    "type": "integer"
                },
                "page": {
                    "type": "integer"
                },
                "records": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/AttendanceResponse"
                    }
                },
                "total": {
                    "type": "integer"
                }
            }
        },
        "ManualAttendanceRequest": {
            "type": "object",
            "required": [
                "check_in_at",
                "check_out_at",
                "reason",
                "user_id"
            ],
            "properties": {
                "check_in_at": {
                    "type": "string"
                },
                "check_out_at": {
                    "type": "string"
                },
                "overtime_seconds": {
                    "type": "integer"
                },
                "reason": {
                    "type": "string",
                    "minLength": 10
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "ReviewTimeOffRequest": {
            "type": "object",
            "required": [
                "review_note"
            ],
            "properties": {
                "review_note": {
                    "type": "string",
                    "minLength": 5
                }
            }
        },
        "TimeOffRequest": {
            "type": "object",
            "required": [
                "end_date",
                "leave_type",
                "reason",
                "start_date"
            ],
            "properties": {
                "end_date": {
                    "type": "string"
                },
                "leave_type": {
                    "enum": [
                        "sick",
                        "vacation",
                        "personal",
                        "unpaid"
                    ],
                    "allOf": [
                        {
                            "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_infrastructure_sqlc.TimeOffRequestsLeaveType"
                        }
                    ]
                },
                "reason": {
                    "type": "string",
                    "minLength": 10
                },
                "start_date": {
                    "type": "string"
                }
            }
        },
        "TimeOffResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "days_count": {
                    "type": "number"
                },
                "email": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "last_name": {
                    "type": "string"
                },
                "leave_type": {
                    "type": "string"
                },
                "reason": {
                    "type": "string"
                },
                "review_note": {
                    "type": "string"
                },
                "reviewed_at": {
                    "type": "string"
                },
                "reviewed_by": {
                    "type": "integer"
                },
                "start_date": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "github_com_waqasmani_go-boilerplate_internal_infrastructure_sqlc.TimeOffRequestsLeaveType": {
            "type": "string",
            "enum": [
                "sick",
                "vacation",
                "personal",
                "unpaid"
            ],
            "x-enum-varnames": [
                "TimeOffRequestsLeaveTypeSick",
                "TimeOffRequestsLeaveTypeVacation",
                "TimeOffRequestsLeaveTypePersonal",
                "TimeOffRequestsLeaveTypeUnpaid"
            ]
        },
        "github_com_waqasmani_go-boilerplate_internal_shared_utils.ErrorResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "details": {},
                "message": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "github_com_waqasmani_go-boilerplate_internal_shared_utils.Response": {
            "type": "object",
            "properties": {
                "data": {},
                "error": {
                    "$ref": "#/definitions/github_com_waqasmani_go-boilerplate_internal_shared_utils.ErrorResponse"
                },
                "success": {
                    "type": "boolean"
                },
                "version": {
                    "type": "string"
                }
            }
        },
        "internal_modules_auth.AuthResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/internal_modules_auth.UserResponse"
                }
            }
        },
        "internal_modules_auth.LoginRequest": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "internal_modules_auth.RegisterRequest": {
            "type": "object",
            "required": [
                "email",
                "first_name",
                "last_name",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "minLength": 8
                }
            }
        },
        "internal_modules_auth.UserResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "last_name": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            }
        },
        "internal_modules_health.DatabaseHealth": {
            "type": "object",
            "properties": {
                "idle": {
                    "type": "integer"
                },
                "in_use": {
                    "type": "integer"
                },
                "max_open_conns": {
                    "type": "integer"
                },
                "open_connections": {
                    "type": "integer"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "internal_modules_health.HealthResponse": {
            "type": "object",
            "properties": {
                "database": {
                    "$ref": "#/definitions/internal_modules_health.DatabaseHealth"
                },
                "redis": {
                    "$ref": "#/definitions/internal_modules_health.RedisHealth"
                },
                "status": {
                    "type": "string"
                },
                "system": {
                    "$ref": "#/definitions/internal_modules_health.SystemHealth"
                },
                "uptime": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                }
            }
        },
        "internal_modules_health.RedisHealth": {
            "type": "object",
            "properties": {
                "latency": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "internal_modules_health.SystemHealth": {
            "type": "object",
            "properties": {
                "mem_alloc_mb": {
                    "type": "integer"
                },
                "num_cpu": {
                    "type": "integer"
                },
                "num_goroutine": {
                    "type": "integer"
                }
            }
        },
        "internal_modules_users.CreateUserRequest": {
            "type": "object",
            "required": [
                "email",
                "first_name",
                "last_name",
                "password",
                "role"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "minLength": 8
                },
                "role": {
                    "type": "string",
                    "enum": [
                        "user",
                        "admin"
                    ]
                }
            }
        },
        "internal_modules_users.ListUsersResponse": {
            "type": "object",
            "properties": {
                "limit": {
                    "type": "integer"
                },
                "page": {
                    "type": "integer"
                },
                "total": {
                    "type": "integer"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/internal_modules_users.UserResponse"
                    }
                }
            }
        },
        "internal_modules_users.UpdatePasswordRequest": {
            "type": "object",
            "required": [
                "new_password",
                "old_password"
            ],
            "properties": {
                "new_password": {
                    "type": "string",
                    "minLength": 8
                },
                "old_password": {
                    "type": "string"
                }
            }
        },
        "internal_modules_users.UpdateUserRequest": {
            "type": "object",
            "required": [
                "first_name",
                "last_name"
            ],
            "properties": {
                "first_name": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                }
            }
        },
        "internal_modules_users.UserResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "is_active": {
                    "type": "boolean"
                },
                "last_name": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "Bearer": {
            "description": "Type \"Bearer \u003cyour_token\u003e\" (include the word Bearer and a space)",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        },
        "CsrfToken": {
            "description": "Enter your CSRF token",
            "type": "apiKey",
            "name": "X-CSRF-TOKEN",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Go Boilerplate API",
        Description:      "This is an attendance and employee management server.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "log"

        "github.com/waqasmani/go-boilerplate/cmd/api/docs"
        "github.com/waqasmani/go-boilerplate/internal/app"
        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/database"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
)

// @title           Go Boilerplate API
// @version         1.0
// @description     This is an attendance and employee management server.

// @securityDefinitions.apikey Bearer
// @in header
// @name Authorization
// @description Type "Bearer &lt;your_token&gt;" (include the word Bearer and a space)

// @securityDefinitions.apikey CsrfToken
// @in header
// @name X-CSRF-TOKEN
// @description Enter your CSRF token
func main() <span class="cov0" title="0">{
        // Load configuration first and validate before any resource initialization
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Configuration loading failed: %v", err)
        }</span>

        // Validate configuration before initializing any resources
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Configuration validation failed: %v", err)
        }</span>

        // Programmatically set swagger info
        <span class="cov0" title="0">docs.SwaggerInfo.BasePath = "/api/v1"

        // Initialize logger after config validation
        logger, err := observability.NewLogger(cfg.Logging.Level, cfg.Logging.Encoding)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to sync logger: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">metrics := observability.NewMetrics()
        // Initialize database after config validation
        db, err := database.NewMariaDB(context.Background(), &amp;cfg.Database, metrics, logger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>

        <span class="cov0" title="0">container := app.NewContainer(cfg, db.DB, logger)
        server := app.NewServer(container)

        if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "database/sql"
        "flag"
        "fmt"
        "log"
        "os"

        "github.com/pressly/goose/v3"
        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/database"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
)

var (
        flags = flag.NewFlagSet("migrate", flag.ExitOnError)
        dir   = flags.String("dir", "./migrations", "directory with migration files")
)

func main() <span class="cov0" title="0">{
        flags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(flags.Output(), "Usage: %s [command] [arguments]\n\n", os.Args[0])
                fmt.Fprintf(flags.Output(), "Commands:\n")
                fmt.Fprintf(flags.Output(), "  create &lt;name&gt; [sql|go]   Create a new migration file\n")
                fmt.Fprintf(flags.Output(), "  up                      Apply all migrations\n")
                fmt.Fprintf(flags.Output(), "  up-by-one               Apply one migration\n")
                fmt.Fprintf(flags.Output(), "  down                    Roll back the last migration\n")
                fmt.Fprintf(flags.Output(), "  down-to &lt;version&gt;       Roll back migrations to specific version\n")
                fmt.Fprintf(flags.Output(), "  redo                    Reapply the last migration\n")
                fmt.Fprintf(flags.Output(), "  reset                   Roll back all migrations\n")
                fmt.Fprintf(flags.Output(), "  status                  Show migration status\n")
                fmt.Fprintf(flags.Output(), "  version                 Show applied version\n")
                fmt.Fprintf(flags.Output(), "\n")
                flags.PrintDefaults()
        }</span>

        <span class="cov0" title="0">flags.Parse(os.Args[1:])
        args := flags.Args()

        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                flags.Usage()
                os.Exit(1)
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Create database connection
        <span class="cov0" title="0">dbConfig := &amp;cfg.Database
        if len(args) &gt; 1 &amp;&amp; args[1] == "test" </span><span class="cov0" title="0">{
                // Use test database for test migrations
                dbConfig.Name = "auth_test_db"
        }</span>
        <span class="cov0" title="0">ctx := context.Background()
        metrics := observability.NewMetrics()
        logger, err := observability.NewLogger(cfg.Logging.Level, cfg.Logging.Encoding)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer logger.Sync()
        dbWrapper, err := database.NewMariaDB(ctx, dbConfig, metrics, logger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer dbWrapper.Close()

        // Get the underlying *sql.DB from the wrapper
        db := dbWrapper.DB

        // Set dialect explicitly for MariaDB/MySQL
        goose.SetDialect("mysql")

        goose.SetTableName("goose_db_version")

        command := args[0]
        switch command </span>{
        case "create":<span class="cov0" title="0">
                handleCreateCommand(db, args)</span>
        case "up", "up-by-one", "down", "redo", "reset", "status", "version":<span class="cov0" title="0">
                handleMigrationCommand(db, command, args)</span>
        case "down-to":<span class="cov0" title="0">
                handleDownToCommand(db, args)</span>
        default:<span class="cov0" title="0">
                log.Fatalf("Unknown command: %s", command)</span>
        }
}

func handleCreateCommand(db *sql.DB, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                log.Fatal("create command requires a migration name")
        }</span>

        <span class="cov0" title="0">name := args[1]
        mtype := "sql" // default to SQL migration
        if len(args) &gt; 2 </span><span class="cov0" title="0">{
                mtype = args[2]
                if mtype != "sql" &amp;&amp; mtype != "go" </span><span class="cov0" title="0">{
                        log.Fatalf("Invalid migration type: %s. Must be 'sql' or 'go'", mtype)
                }</span>
        }

        <span class="cov0" title="0">if err := goose.Create(db, *dir, name, mtype); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create migration: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Created new %s migration: %s", mtype, name)</span>
}

func handleMigrationCommand(db *sql.DB, command string, args []string) <span class="cov0" title="0">{
        var err error
        switch command </span>{
        case "up":<span class="cov0" title="0">
                err = goose.Up(db, *dir)</span>
        case "up-by-one":<span class="cov0" title="0">
                err = goose.UpByOne(db, *dir)</span>
        case "down":<span class="cov0" title="0">
                err = goose.Down(db, *dir)</span>
        case "redo":<span class="cov0" title="0">
                err = goose.Redo(db, *dir)</span>
        case "reset":<span class="cov0" title="0">
                err = goose.Reset(db, *dir)</span>
        case "status":<span class="cov0" title="0">
                err = goose.Status(db, *dir)</span>
        case "version":<span class="cov0" title="0">
                err = goose.Version(db, *dir)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Migration failed: %v", err)
        }</span>
}

func handleDownToCommand(db *sql.DB, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                log.Fatal("down-to command requires a version number")
        }</span>

        <span class="cov0" title="0">version, err := parseVersion(args[1])
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid version: %v", err)
        }</span>

        <span class="cov0" title="0">if err := goose.DownTo(db, *dir, version); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to roll back to version %d: %v", version, err)
        }</span>
}

func parseVersion(str string) (int64, error) <span class="cov0" title="0">{
        var version int64
        _, err := fmt.Sscanf(str, "%d", &amp;version)
        return version, err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "context"
        "database/sql"
        "fmt"
        "sync"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/database"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/security"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/sqlc"
        "github.com/waqasmani/go-boilerplate/internal/modules/health"
        "github.com/waqasmani/go-boilerplate/internal/shared/validator"
        "go.uber.org/zap"
)

type Container struct {
        Config          *config.Config
        DB              *sql.DB
        Logger          *observability.Logger
        Queries         *sqlc.Queries
        Repo            *sqlc.Repository
        JWTService      *security.JWTService
        PasswordService *security.PasswordService
        AuthMiddleware  *middleware.AuthMiddleware
        Validator       *validator.Validator
        Metrics         *observability.Metrics
        AuditLogger     *observability.AuditLogger
        HealthHandler   *health.Handler
        rateLimiter     security.RateLimiter
        redisMu         sync.RWMutex
        redisClient     *redis.Client
}

func NewContainer(cfg *config.Config, db *sql.DB, logger *observability.Logger) *Container <span class="cov8" title="1">{
        metrics := observability.NewMetrics()
        jwtService := security.NewJWTService(&amp;cfg.JWT)
        passwordService := security.NewPasswordService(cfg.Security.BcryptCost)
        validatorInstance := validator.New()

        var auditLogger *observability.AuditLogger
        if cfg.AuditLog.Enabled &amp;&amp; cfg.AuditLog.Path != "" </span><span class="cov0" title="0">{
                dedicatedAuditLogger, err := observability.NewDedicatedAuditLogger(
                        cfg.AuditLog.Path,
                        cfg.AuditLog.Format,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(context.Background(), "Failed to initialize dedicated audit logger, falling back to main logger",
                                zap.Error(err),
                                zap.String("path", cfg.AuditLog.Path),
                        )
                        auditLogger = observability.NewAuditLogger(logger)
                }</span> else<span class="cov0" title="0"> {
                        logger.Info(context.Background(), "Audit logging enabled with dedicated file",
                                zap.String("path", cfg.AuditLog.Path),
                                zap.String("format", cfg.AuditLog.Format),
                        )
                        auditLogger = dedicatedAuditLogger
                }</span>
        } else<span class="cov8" title="1"> {
                auditLogger = observability.NewAuditLogger(logger)
        }</span>

        <span class="cov8" title="1">var queryDB database.DBTX = db
        if cfg.Database.CircuitBreaker.Enabled </span><span class="cov8" title="1">{
                logger.Info(context.Background(), "Initializing database circuit breaker",
                        zap.Bool("enabled", cfg.Database.CircuitBreaker.Enabled),
                        zap.Uint32("max_failures", cfg.Database.CircuitBreaker.MaxFailures),
                        zap.Float64("failure_threshold", cfg.Database.CircuitBreaker.FailureThreshold),
                        zap.Duration("reset_timeout", cfg.Database.CircuitBreaker.ResetTimeout),
                )
                // Use the DB wrapper with circuit breaker that also has retry configuration
                queryDB = database.NewBreakerDB(db, cfg.Database.CircuitBreaker, metrics, logger)
        }</span>

        <span class="cov8" title="1">queries := sqlc.New(queryDB)
        repo := sqlc.NewRepository(db)
        authMiddleware := middleware.NewAuthMiddleware(jwtService)
        healthHandler := health.NewHandler(db, cfg.Redis.Enabled)

        return &amp;Container{
                Config:          cfg,
                DB:              db,
                Logger:          logger,
                Queries:         queries,
                Repo:            repo,
                JWTService:      jwtService,
                PasswordService: passwordService,
                AuthMiddleware:  authMiddleware,
                Validator:       validatorInstance,
                Metrics:         metrics,
                AuditLogger:     auditLogger,
                HealthHandler:   healthHandler,
        }</span>
}

// GetRedisClient provides a thread-safe singleton that allows retries on failure
// GetRedisClient provides a thread-safe singleton that allows retries on failure
func (c *Container) GetRedisClient() (*redis.Client, error) <span class="cov0" title="0">{
        c.redisMu.RLock()
        if c.redisClient != nil </span><span class="cov0" title="0">{
                client := c.redisClient
                c.redisMu.RUnlock()
                return client, nil
        }</span>
        <span class="cov0" title="0">c.redisMu.RUnlock()

        c.redisMu.Lock()
        defer c.redisMu.Unlock()

        // Double-check after acquiring lock
        if c.redisClient != nil </span><span class="cov0" title="0">{
                return c.redisClient, nil
        }</span>

        <span class="cov0" title="0">client := redis.NewClient(&amp;redis.Options{
                Addr:         fmt.Sprintf("%s:%s", c.Config.Redis.Host, c.Config.Redis.Port),
                Password:     c.Config.Redis.Password,
                DB:           c.Config.Redis.DB,
                DialTimeout:  5 * time.Second,
                ReadTimeout:  3 * time.Second,
                WriteTimeout: 3 * time.Second,
                PoolSize:     c.Config.Redis.PoolSize,
                MinIdleConns: c.Config.Redis.MinIdleConns,
                MaxRetries:   c.Config.Redis.MaxRetries,
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                client.Close()
                c.redisClient = nil // Explicitly nullify on failure
                return nil, fmt.Errorf("redis connection failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.redisClient = client
        return c.redisClient, nil</span>
}

func (c *Container) GetRateLimiter() security.RateLimiter <span class="cov8" title="1">{
        if c.rateLimiter != nil </span><span class="cov0" title="0">{
                return c.rateLimiter
        }</span>

        <span class="cov8" title="1">if c.Config.Redis.Enabled </span><span class="cov0" title="0">{
                client, err := c.GetRedisClient()
                if err != nil </span><span class="cov0" title="0">{
                        // Only fatal in production, log warning in other environments
                        if c.Config.Server.Env == "production" </span><span class="cov0" title="0">{
                                c.Logger.Fatal(context.Background(),
                                        "Redis required for rate limiting in production but unavailable",
                                        zap.Error(err),
                                        zap.String("redis_host", c.Config.Redis.Host),
                                        zap.String("redis_port", c.Config.Redis.Port),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                c.Logger.Warn(context.Background(),
                                        "Redis connection failed, falling back to in-memory rate limiter",
                                        zap.Error(err),
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Redis connection succeeded
                        c.Logger.Info(context.Background(),
                                "Successfully connected to Redis for rate limiting and CSRF protection",
                                zap.String("redis_host", c.Config.Redis.Host),
                        )
                        c.rateLimiter = security.NewRedisRateLimiter(client)
                        return c.rateLimiter
                }</span>
        }

        // Fallback to in-memory rate limiter
        <span class="cov8" title="1">if c.Config.Server.Env == "production" &amp;&amp; c.Config.Redis.Enabled </span><span class="cov0" title="0">{
                c.Logger.Warn(context.Background(),
                        "Using in-memory rate limiter in production - not recommended for multi-instance deployments",
                )
        }</span> else<span class="cov8" title="1"> if !c.Config.Redis.Enabled </span><span class="cov8" title="1">{
                c.Logger.Info(context.Background(), "Redis disabled in configuration, using in-memory rate limiter")
        }</span>

        <span class="cov8" title="1">c.rateLimiter = security.NewInMemoryRateLimiter()
        return c.rateLimiter</span>
}

// Close gracefully closes all infrastructure connections
func (c *Container) Close() <span class="cov0" title="0">{
        if c.AuditLogger != nil </span><span class="cov0" title="0">{
                if err := c.AuditLogger.Close(); err != nil </span><span class="cov0" title="0">{
                        c.Logger.Error(context.Background(), "Error closing audit logger", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">c.redisMu.Lock()
        defer c.redisMu.Unlock()

        if c.DB != nil </span><span class="cov0" title="0">{
                if err := c.DB.Close(); err != nil </span><span class="cov0" title="0">{
                        c.Logger.Error(context.Background(), "Error closing DB", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if c.redisClient != nil </span><span class="cov0" title="0">{
                if err := c.redisClient.Close(); err != nil </span><span class="cov0" title="0">{
                        c.Logger.Error(context.Background(), "Error closing Redis", zap.Error(err))
                }</span>
                <span class="cov0" title="0">c.redisClient = nil</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "context"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware"
        "github.com/waqasmani/go-boilerplate/internal/modules/attendance"
        "github.com/waqasmani/go-boilerplate/internal/modules/auth"
        "github.com/waqasmani/go-boilerplate/internal/modules/health"
        "github.com/waqasmani/go-boilerplate/internal/modules/users"
)

func SetupRouter(container *Container) *gin.Engine <span class="cov8" title="1">{
        if container.Config.Server.Env == "production" </span><span class="cov8" title="1">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        <span class="cov8" title="1">router := gin.New()
        router.Use(gin.Recovery())
        router.Use(middleware.BodyLimitMiddleware(2 * 1024 * 1024))
        if len(container.Config.Server.TrustedProxies) &gt; 0 </span><span class="cov8" title="1">{
                router.SetTrustedProxies(container.Config.Server.TrustedProxies)
        }</span> else<span class="cov8" title="1"> if container.Config.Server.Env == "production" </span><span class="cov8" title="1">{
                container.Logger.Warn(context.Background(), "Production mode active with no TrustedProxies configured")
        }</span>
        <span class="cov8" title="1">router.Use(middleware.PanicRecoveryMiddleware(container.Logger))
        router.Use(middleware.RequestIDMiddleware())
        router.Use(middleware.ErrorHandlingMiddleware(container.Logger, container.Metrics))
        router.Use(middleware.TracingMiddleware(container.Logger))
        router.Use(middleware.LoggerMiddleware(container.Logger))
        router.Use(middleware.TimeoutMiddleware(30 * time.Second))
        router.Use(middleware.NewCORSMiddleware(container.Config.CORS))
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        router.Use(middleware.SecurityHeadersMiddleware())
        if container.Config.Metrics.Enabled </span><span class="cov8" title="1">{
                router.Use(middleware.MetricsMiddleware(container.Metrics))
        }</span>

        // Health Handler &amp; Route
        <span class="cov8" title="1">healthHandler := health.NewHandler(container.DB, container.Config.Redis.Enabled)
        if container.Config.Redis.Enabled </span><span class="cov0" title="0">{
                healthHandler.SetRedisClientProvider(container.GetRedisClient)
        }</span>
        <span class="cov8" title="1">health.RegisterRoutes(router, healthHandler)

        // Auth Services &amp; Routes
        authService := auth.NewService(
                container.Queries,
                container.Repo,
                container.JWTService,
                container.PasswordService,
                container.Validator,
                container.AuditLogger,
                container.Metrics,
                container.Config,
                container.Logger,
        )
        authHandler := auth.NewHandler(authService)
        rateLimiter := container.GetRateLimiter()
        auth.RegisterRoutes(router, authHandler, container.AuthMiddleware, rateLimiter)

        // User Services &amp; Routes
        usersService := users.NewService(
                container.Queries,
                container.Repo,
                container.PasswordService,
                container.Validator,
                container.AuditLogger,
                container.Logger,
        )
        usersHandler := users.NewHandler(usersService)
        users.RegisterRoutes(router, usersHandler, container.AuthMiddleware)

        // Attendance Services &amp; Routes
        attendanceService := attendance.NewService(
                container.Queries,
                container.AuditLogger,
                container.Validator,
                container.Logger,
                container.Config,
        )
        attendanceHandler := attendance.NewHandler(attendanceService)
        attendance.RegisterRoutes(router, attendanceHandler, container.AuthMiddleware)

        // Metrics Route
        if container.Config.Metrics.Enabled </span><span class="cov8" title="1">{
                router.GET("/api/v1/metrics", gin.WrapH(promhttp.Handler()))
        }</span>

        <span class="cov8" title="1">return router</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type Server struct {
        router       *gin.Engine
        container    *Container
        httpServer   *http.Server
        workerCtx    context.Context
        workerCancel context.CancelFunc
        workerWG     sync.WaitGroup
}

func NewServer(container *Container) *Server <span class="cov8" title="1">{
        router := SetupRouter(container)
        workerCtx, workerCancel := context.WithCancel(context.Background())
        return &amp;Server{
                router:       router,
                container:    container,
                workerCtx:    workerCtx,
                workerCancel: workerCancel,
        }
}</span>

func (s *Server) Start() error <span class="cov0" title="0">{
        s.startBackgroundWorkers()
        s.startMetricsCollector()
        addr := fmt.Sprintf("%s:%s", s.container.Config.Server.Host, s.container.Config.Server.Port)
        s.httpServer = &amp;http.Server{
                Addr:           addr,
                Handler:        s.router,
                ReadTimeout:    15 * time.Second,
                WriteTimeout:   15 * time.Second,
                IdleTimeout:    60 * time.Second,
                MaxHeaderBytes: 1 &lt;&lt; 20,
        }

        s.container.Logger.Info(s.workerCtx,
                fmt.Sprintf("Starting server on %s", addr),
                zap.String("env", s.container.Config.Server.Env),
        )

        errChan := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("server failed: %w", err)
                }</span>
        }()

        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return err</span>
        case sig := &lt;-sigChan:<span class="cov0" title="0">
                s.container.Logger.Info(s.workerCtx, "Shutdown signal received", zap.String("signal", sig.String()))
                return s.gracefulShutdown()</span>
        }
}

func (s *Server) startBackgroundWorkers() <span class="cov0" title="0">{
        interval := s.container.Config.Security.RefreshTokenCleanupInterval
        if interval &lt;= 0 </span><span class="cov0" title="0">{
                interval = 24 * time.Hour
        }</span>

        <span class="cov0" title="0">s.workerWG.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer s.workerWG.Done()
                ticker := time.NewTicker(interval)
                defer ticker.Stop()
                s.container.Logger.Info(s.workerCtx, "Starting background workers", zap.Duration("cleanup_interval", interval))
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.cleanupExpiredTokens()</span>
                        case &lt;-s.workerCtx.Done():<span class="cov0" title="0">
                                s.container.Logger.Info(s.workerCtx, "Stopping background workers...")
                                return</span>
                        }
                }
        }()
}

func (s *Server) startMetricsCollector() <span class="cov0" title="0">{
        if !s.container.Config.Metrics.Enabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.workerWG.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer s.workerWG.Done()
                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        // Prioritize shutdown signal in the select logic
                        case &lt;-s.workerCtx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                // Double-check context to prevent starting work during race conditions
                                if s.workerCtx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">s.collectDatabaseMetrics()</span>
                        }
                }
        }()
}

func (s *Server) collectDatabaseMetrics() <span class="cov0" title="0">{
        stats := s.container.DB.Stats()
        s.container.Metrics.RecordDatabaseStats(
                stats.OpenConnections,
                stats.InUse,
                stats.Idle,
        )
}</span>

func (s *Server) cleanupExpiredTokens() <span class="cov8" title="1">{
        start := time.Now()
        jobName := "token_cleanup"
        ctx := s.workerCtx
        defer func() </span><span class="cov8" title="1">{
                duration := time.Since(start)
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.container.Logger.Error(ctx, "Panic in cleanup job", zap.Any("error", r), zap.String("job", jobName))
                        s.container.Metrics.RecordBackgroundJob(jobName, duration, fmt.Errorf("panic: %v", r))
                }</span>
        }()

        <span class="cov8" title="1">batchSize := int32(s.container.Config.Security.RefreshTokenCleanupBatchSize)
        totalDeleted := int64(0)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.container.Logger.Info(ctx, "Token cleanup interrupted, exiting")
                        return</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">batchCtx, batchCancel := context.WithTimeout(ctx, 30*time.Second)
                defer batchCancel()

                result, err := s.container.Queries.DeleteExpiredRefreshTokens(batchCtx, batchSize)
                if err != nil </span><span class="cov0" title="0">{
                        duration := time.Since(start)
                        s.container.Logger.Error(ctx, "Failed to clean up expired refresh tokens", zap.Error(err), zap.Duration("duration", duration))
                        s.container.Metrics.RecordBackgroundJob(jobName, duration, err)
                        return
                }</span>

                <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
                if err != nil </span><span class="cov0" title="0">{
                        s.container.Logger.Error(ctx, "Failed to get rows affected", zap.Error(err))
                        return
                }</span>

                <span class="cov8" title="1">totalDeleted += rowsAffected
                if rowsAffected &lt; int64(batchSize) </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov8" title="1">duration := time.Since(start)
        if totalDeleted &gt; 0 </span><span class="cov8" title="1">{
                s.container.Logger.Info(ctx, "Cleaned up expired refresh tokens", zap.Int64("count", totalDeleted), zap.Duration("duration", duration))
        }</span>
        <span class="cov8" title="1">s.container.Metrics.RecordBackgroundJob(jobName, duration, nil)</span>
}

func (s *Server) gracefulShutdown() error <span class="cov0" title="0">{
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        s.container.Logger.Info(s.workerCtx, "Shutting down HTTP server...")
        if err := s.httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                s.container.Logger.Error(s.workerCtx, "HTTP server shutdown failed", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.container.Logger.Info(s.workerCtx, "Stopping background workers...")
        s.workerCancel()

        shutdownDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                s.workerWG.Wait()
                close(shutdownDone)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-shutdownDone:<span class="cov0" title="0">
                s.container.Logger.Info(s.workerCtx, "Background workers finished")</span>
        case &lt;-time.After(10 * time.Second):<span class="cov0" title="0">
                s.container.Logger.Warn(s.workerCtx, "Background workers did not finish in time, proceeding with shutdown")</span>
        }

        <span class="cov0" title="0">s.container.Logger.Info(s.workerCtx, "Closing infrastructure connections...")
        s.container.Close()
        s.container.Logger.Info(s.workerCtx, "Server exited gracefully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "fmt"
        "os"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/joho/godotenv"
)

type AuditLogConfig struct {
        Enabled bool   `mapstructure:"enabled"`
        Path    string `mapstructure:"path"`
        Format  string `mapstructure:"format"`
}

type DatabaseRetryConfig struct {
        Enabled         *bool          `mapstructure:"enabled"`
        MaxRetries      *int           `mapstructure:"max_retries"`
        InitialInterval *time.Duration `mapstructure:"initial_interval"`
        MaxInterval     *time.Duration `mapstructure:"max_interval"`
        Multiplier      *float64       `mapstructure:"multiplier"`
        Randomization   *float64       `mapstructure:"randomization"`
        FatalErrorTypes []string       `mapstructure:"fatal_error_types"`
}

type Config struct {
        Server   ServerConfig   `mapstructure:"server"`
        Database DatabaseConfig `mapstructure:"database"`
        JWT      JWTConfig      `mapstructure:"jwt"`
        Security SecurityConfig `mapstructure:"security"`
        CORS     CORSConfig     `mapstructure:"cors"`
        Logging  LoggingConfig  `mapstructure:"logging"`
        Metrics  MetricsConfig  `mapstructure:"metrics"`
        Redis    RedisConfig    `mapstructure:"redis"`
        AuditLog AuditLogConfig `mapstructure:"audit_log"`
}

type RedisConfig struct {
        Enabled         bool          `mapstructure:"enabled"`
        Host            string        `mapstructure:"host"`
        Port            string        `mapstructure:"port"`
        Password        string        `mapstructure:"password"`
        DB              int           `mapstructure:"db"`
        MaxRetries      int           `mapstructure:"max_retries"`
        PoolSize        int           `mapstructure:"pool_size"`
        MinIdleConns    int           `mapstructure:"min_idle_conns"`
        ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime"`
}

type ServerConfig struct {
        Port            string        `mapstructure:"port"`
        Host            string        `mapstructure:"host"`
        Env             string        `mapstructure:"env"`
        ReadTimeout     time.Duration `mapstructure:"read_timeout"`
        WriteTimeout    time.Duration `mapstructure:"write_timeout"`
        IdleTimeout     time.Duration `mapstructure:"idle_timeout"`
        ShutdownTimeout time.Duration `mapstructure:"shutdown_timeout"`
        UseHTTPS        bool          `mapstructure:"use_https"`
        TrustedProxies  []string      `mapstructure:"trusted_proxies"`
}

type DatabaseConfig struct {
        Host            string              `mapstructure:"host"`
        Port            string              `mapstructure:"port"`
        User            string              `mapstructure:"user"`
        Password        string              `mapstructure:"password"`
        Name            string              `mapstructure:"name"`
        MaxOpenConns    int                 `mapstructure:"max_open_conns"`
        MaxIdleConns    int                 `mapstructure:"max_idle_conns"`
        ConnMaxLifetime time.Duration       `mapstructure:"conn_max_lifetime"`
        ConnMaxIdleTime time.Duration       `mapstructure:"conn_max_idle_time"`
        SlowQueryTime   time.Duration       `mapstructure:"slow_query_time"`
        Retry           DatabaseRetryConfig `mapstructure:"retry"`
        CircuitBreaker  CBConfig            `mapstructure:"circuit_breaker"`
}

type CBConfig struct {
        Enabled          bool          `mapstructure:"enabled"`
        MaxFailures      uint32        `mapstructure:"max_failures"`
        FailureThreshold float64       `mapstructure:"failure_threshold"`
        ResetTimeout     time.Duration `mapstructure:"reset_timeout"`
}

type JWTConfig struct {
        AccessSecret  string        `mapstructure:"access_secret"`
        AccessExpiry  time.Duration `mapstructure:"access_expiry"`
        RefreshExpiry time.Duration `mapstructure:"refresh_expiry"`
}

type SecurityConfig struct {
        BcryptCost                   int           `mapstructure:"bcrypt_cost"`
        RefreshTokenCleanupInterval  time.Duration `mapstructure:"refresh_token_cleanup_interval"`
        RefreshTokenCleanupBatchSize int           `mapstructure:"refresh_token_cleanup_batch_size"`
        MaxLoginAttempts             int           `mapstructure:"max_login_attempts"`
        LoginLockoutDuration         time.Duration `mapstructure:"login_lockout_duration"`
        SessionBindingEnabled        bool          `mapstructure:"session_binding_enabled"`
        DatabaseRetryEnabled         bool          `mapstructure:"database_retry_enabled"`
}

type CORSConfig struct {
        AllowedOrigins []string `mapstructure:"allowed_origins"`
        AllowedMethods []string `mapstructure:"allowed_methods"`
        AllowedHeaders []string `mapstructure:"allowed_headers"`
}

type LoggingConfig struct {
        Level    string `mapstructure:"level"`
        Encoding string `mapstructure:"encoding"`
}

type MetricsConfig struct {
        Enabled bool `mapstructure:"enabled"`
}

func Load() (*Config, error) <span class="cov8" title="1">{
        if err := godotenv.Load(); err != nil </span><span class="cov8" title="1">{
                fmt.Println("Warning: .env file not found, using environment variables")
        }</span>

        <span class="cov8" title="1">cfg := &amp;Config{
                Server: ServerConfig{
                        Port:            getEnv("SERVER_PORT", "8080"),
                        Host:            getEnv("SERVER_HOST", "localhost"),
                        Env:             getEnv("ENV", "development"),
                        ReadTimeout:     getEnvAsDuration("SERVER_READ_TIMEOUT", 15*time.Second),
                        WriteTimeout:    getEnvAsDuration("SERVER_WRITE_TIMEOUT", 15*time.Second),
                        IdleTimeout:     getEnvAsDuration("SERVER_IDLE_TIMEOUT", 60*time.Second),
                        ShutdownTimeout: getEnvAsDuration("SERVER_SHUTDOWN_TIMEOUT", 30*time.Second),
                        UseHTTPS:        getEnvAsBool("SERVER_USE_HTTPS", false),
                        TrustedProxies:  getEnvAsSlice("SERVER_TRUSTED_PROXIES", []string{"127.0.0.1"}),
                },
                Database: DatabaseConfig{
                        Host:            getEnv("DB_HOST", "localhost"),
                        Port:            getEnv("DB_PORT", "3306"),
                        User:            getEnv("DB_USER", "apiuser"),
                        Password:        getEnv("DB_PASSWORD", "apipassword"),
                        Name:            getEnv("DB_NAME", "apidb"),
                        MaxOpenConns:    getEnvAsInt("DB_MAX_OPEN_CONNS", 25),
                        MaxIdleConns:    getEnvAsInt("DB_MAX_IDLE_CONNS", 5),
                        ConnMaxLifetime: getEnvAsDuration("DB_CONN_MAX_LIFETIME", 5*time.Minute),
                        ConnMaxIdleTime: getEnvAsDuration("DB_CONN_MAX_IDLE_TIME", 5*time.Minute),
                        SlowQueryTime:   getEnvAsDuration("DB_SLOW_QUERY_TIME", 500*time.Millisecond),
                        Retry: DatabaseRetryConfig{
                                Enabled:         getEnvAsBoolPtr("DB_RETRY_ENABLED", true),
                                MaxRetries:      getEnvAsIntPtr("DB_RETRY_MAX_RETRIES", 3),
                                InitialInterval: getEnvAsDurationPtr("DB_RETRY_INITIAL_INTERVAL", 100*time.Millisecond),
                                MaxInterval:     getEnvAsDurationPtr("DB_RETRY_MAX_INTERVAL", 2*time.Second),
                                Multiplier:      getEnvAsFloatPtr("DB_RETRY_MULTIPLIER", 2.0),
                                Randomization:   getEnvAsFloatPtr("DB_RETRY_RANDOMIZATION", 0.2),
                                FatalErrorTypes: getEnvAsSlice("DB_RETRY_FATAL_ERROR_TYPES", []string{"constraint_violation", "duplicate_key", "foreign_key_violation"}),
                        },
                        CircuitBreaker: CBConfig{
                                Enabled:          getEnvAsBool("DB_CIRCUIT_BREAKER_ENABLED", true),
                                MaxFailures:      uint32(getEnvAsInt("DB_MAX_FAILURES", 5)),
                                FailureThreshold: getEnvAsFloat("DB_FAILURE_THRESHOLD", 0.5),
                                ResetTimeout:     getEnvAsDuration("DB_RESET_TIMEOUT", 30*time.Second),
                        },
                },
                JWT: JWTConfig{
                        AccessSecret:  getEnv("JWT_ACCESS_SECRET", ""),
                        AccessExpiry:  getEnvAsDuration("JWT_ACCESS_EXPIRY", 15*time.Minute),
                        RefreshExpiry: getEnvAsDuration("JWT_REFRESH_EXPIRY", 168*time.Hour),
                },
                Security: SecurityConfig{
                        BcryptCost:                   getEnvAsInt("BCRYPT_COST", 12),
                        RefreshTokenCleanupInterval:  getEnvAsDuration("REFRESH_TOKEN_CLEANUP_INTERVAL", 24*time.Hour),
                        RefreshTokenCleanupBatchSize: getEnvAsInt("REFRESH_TOKEN_CLEANUP_BATCH_SIZE", 1000),
                        MaxLoginAttempts:             getEnvAsInt("MAX_LOGIN_ATTEMPTS", 5),
                        LoginLockoutDuration:         getEnvAsDuration("LOGIN_LOCKOUT_DURATION", 15*time.Minute),
                        SessionBindingEnabled:        getEnvAsBool("SESSION_BINDING_ENABLED", true),
                        DatabaseRetryEnabled:         getEnvAsBool("DATABASE_RETRY_ENABLED", true),
                },
                CORS: CORSConfig{
                        AllowedOrigins: getEnvAsSlice("CORS_ALLOWED_ORIGINS", []string{"*"}),
                        AllowedMethods: getEnvAsSlice("CORS_ALLOWED_METHODS", []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"}),
                        AllowedHeaders: getEnvAsSlice("CORS_ALLOWED_HEADERS", []string{"Content-Type", "Authorization"}),
                },
                Logging: LoggingConfig{
                        Level:    getEnv("LOG_LEVEL", "info"),
                        Encoding: getEnv("LOG_ENCODING", "json"),
                },
                Metrics: MetricsConfig{
                        Enabled: getEnvAsBool("ENABLE_METRICS", true),
                },
                AuditLog: AuditLogConfig{
                        Enabled: getEnvAsBool("AUDIT_LOG_ENABLED", true),
                        Path:    getEnv("AUDIT_LOG_PATH", ""),
                        Format:  getEnv("AUDIT_LOG_FORMAT", "json"),
                },
                Redis: RedisConfig{
                        Enabled:         getEnvAsBool("ENABLE_REDIS", false),
                        Host:            getEnv("REDIS_HOST", "localhost"),
                        Port:            getEnv("REDIS_PORT", "6379"),
                        Password:        getEnv("REDIS_PASSWORD", ""),
                        DB:              getEnvAsInt("REDIS_DB", 0),
                        MaxRetries:      getEnvAsInt("REDIS_MAX_RETRIES", 3),
                        PoolSize:        getEnvAsInt("REDIS_POOL_SIZE", 10),
                        MinIdleConns:    getEnvAsInt("REDIS_MIN_IDLE_CONNS", 5),
                        ConnMaxLifetime: getEnvAsDuration("REDIS_CONN_MAX_LIFETIME", 30*time.Minute),
                },
        }

        return cfg, nil</span>
}

func (c *Config) Validate() error <span class="cov8" title="1">{
        // Common validation for all environments
        if err := c.validateDependencies(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Environment-specific validation
        <span class="cov8" title="1">switch c.Server.Env </span>{
        case "production":<span class="cov8" title="1">
                if err := c.validateProduction(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        case "staging":<span class="cov8" title="1">
                if err := c.validateStaging(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *Config) validateDependencies() error <span class="cov8" title="1">{
        if c.Database.CircuitBreaker.Enabled </span><span class="cov8" title="1">{
                if c.Database.CircuitBreaker.MaxFailures &lt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("DB_MAX_FAILURES must be at least 1 when circuit breaker is enabled")
                }</span>
                <span class="cov8" title="1">if c.Database.CircuitBreaker.FailureThreshold &lt;= 0 ||
                        c.Database.CircuitBreaker.FailureThreshold &gt; 1.0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("DB_FAILURE_THRESHOLD must be between 0 and 1.0")
                }</span>
                <span class="cov8" title="1">if c.Database.CircuitBreaker.ResetTimeout &lt;= 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("DB_RESET_TIMEOUT must be greater than 0")
                }</span>
        }

        <span class="cov8" title="1">if c.Redis.Enabled &amp;&amp; c.Redis.Host == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("redis host required when redis is enabled")
        }</span>

        <span class="cov8" title="1">if c.JWT.AccessSecret == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("JWT_ACCESS_SECRET is required")
        }</span>
        <span class="cov8" title="1">if len(c.JWT.AccessSecret) &lt; 32 </span><span class="cov8" title="1">{
                return fmt.Errorf("JWT access secret must be at least 32 characters long")
        }</span>
        <span class="cov8" title="1">if c.Database.MaxIdleConns &gt; c.Database.MaxOpenConns </span><span class="cov8" title="1">{
                return fmt.Errorf("DB_MAX_IDLE_CONNS cannot exceed DB_MAX_OPEN_CONNS")
        }</span>

        <span class="cov8" title="1">if c.Database.SlowQueryTime &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("DB_SLOW_QUERY_TIME must be greater than 0")
        }</span>

        <span class="cov8" title="1">if c.Security.BcryptCost &lt; 4 </span><span class="cov8" title="1">{
                return fmt.Errorf("BCRYPT_COST must be at least 4")
        }</span>

        <span class="cov8" title="1">if c.Server.ReadTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("SERVER_READ_TIMEOUT must be greater than 0")
        }</span>
        <span class="cov8" title="1">if c.Server.WriteTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("SERVER_WRITE_TIMEOUT must be greater than 0")
        }</span>
        <span class="cov8" title="1">if c.Server.ShutdownTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("SERVER_SHUTDOWN_TIMEOUT must be greater than 0")
        }</span>

        <span class="cov8" title="1">if c.Security.RefreshTokenCleanupInterval &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("REFRESH_TOKEN_CLEANUP_INTERVAL must be greater than 0")
        }</span>

        <span class="cov8" title="1">if c.Security.LoginLockoutDuration &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("LOGIN_LOCKOUT_DURATION must be greater than 0")
        }</span>

        <span class="cov8" title="1">if c.Security.MaxLoginAttempts &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("MAX_LOGIN_ATTEMPTS must be at least 1")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *Config) validateProduction() error <span class="cov8" title="1">{
        if len(c.JWT.AccessSecret) &lt; 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("FATAL SECURITY: JWT access secret must be at least 32 characters long in production")
        }</span>
        // Check for default/insecure JWT secrets
        <span class="cov8" title="1">insecureDefaults := []string{
                "change-this-to-a-secure-random-string",
                "change-this-to-another-secure-random-string",
                "secret",
                "your-secret-key",
        }

        for _, defaultVal := range insecureDefaults </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(c.JWT.AccessSecret), strings.ToLower(defaultVal)) </span><span class="cov8" title="1">{
                        return fmt.Errorf("FATAL SECURITY: Default/insecure JWT Access Secret detected in production. Please generate a cryptographically secure secret with at least 32 random characters")
                }</span>
        }

        // Validate password strength
        <span class="cov8" title="1">weakPasswords := []string{"password", "apipassword", "admin", "root", "test", ""}
        dbPass := strings.ToLower(c.Database.Password)
        for _, weak := range weakPasswords </span><span class="cov8" title="1">{
                if dbPass == weak </span><span class="cov8" title="1">{
                        return fmt.Errorf("FATAL SECURITY: Weak or default database password detected in production (current: %s). Use a strong password with at least 16 characters, including uppercase, lowercase, numbers, and special characters", weak)
                }</span>
        }
        // Validate password complexity
        <span class="cov8" title="1">if len(c.Database.Password) &lt; 16 </span><span class="cov8" title="1">{
                return fmt.Errorf("FATAL SECURITY: Database password must be at least 16 characters in production (current length: %d)", len(c.Database.Password))
        }</span>
        <span class="cov8" title="1">if !hasPasswordComplexity(c.Database.Password) </span><span class="cov8" title="1">{
                return fmt.Errorf("FATAL SECURITY: Database password must contain uppercase, lowercase, numbers, and special characters in production")
        }</span>

        // Enforce stronger bcrypt cost in production
        <span class="cov8" title="1">if c.Security.BcryptCost &lt; 12 </span><span class="cov8" title="1">{
                return fmt.Errorf("FATAL SECURITY: BCRYPT_COST must be at least 12 in production (current: %d). Higher values provide better security against brute-force attacks", c.Security.BcryptCost)
        }</span>

        // Validate HTTPS is enabled in production
        <span class="cov8" title="1">if !c.Server.UseHTTPS </span><span class="cov8" title="1">{
                return fmt.Errorf("FATAL SECURITY: HTTPS must be enabled in production (SERVER_USE_HTTPS=true). HTTP connections expose sensitive data including authentication tokens")
        }</span>

        // Validate Redis is properly configured if rate limiting is production critical
        <span class="cov8" title="1">if !c.Redis.Enabled </span><span class="cov8" title="1">{
                return fmt.Errorf("WARNING: Redis is disabled in production. In-memory rate limiting will not work across multiple server instances. Enable Redis for distributed rate limiting")
        }</span>

        // Validate rate limiting configuration
        <span class="cov8" title="1">if c.Security.MaxLoginAttempts &lt; 3 </span><span class="cov8" title="1">{
                return fmt.Errorf("FATAL SECURITY: MAX_LOGIN_ATTEMPTS should be at least 3 in production (current: %d)", c.Security.MaxLoginAttempts)
        }</span>
        <span class="cov8" title="1">if c.Security.LoginLockoutDuration &lt; 5*time.Minute </span><span class="cov8" title="1">{
                return fmt.Errorf("FATAL SECURITY: LOGIN_LOCKOUT_DURATION should be at least 5 minutes in production (current: %v)", c.Security.LoginLockoutDuration)
        }</span>

        // Production logging should be JSON format
        <span class="cov8" title="1">if c.Logging.Encoding != "json" </span><span class="cov8" title="1">{
                return fmt.Errorf("FATAL SECURITY: Production logging should use JSON format for better log aggregation and analysis")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *Config) validateStaging() error <span class="cov8" title="1">{
        // Staging environment should closely mirror production
        if c.Security.BcryptCost &lt; 12 </span><span class="cov8" title="1">{
                return fmt.Errorf("SECURITY WARNING: BCRYPT_COST should be at least 12 in staging (current: %d) to match production security standards", c.Security.BcryptCost)
        }</span>
        <span class="cov8" title="1">if c.Logging.Encoding != "json" </span><span class="cov8" title="1">{
                return fmt.Errorf("WARNING: Staging logging should use JSON format to match production logging configuration")
        }</span>
        <span class="cov8" title="1">if !c.Redis.Enabled </span><span class="cov8" title="1">{
                return fmt.Errorf("WARNING: Redis is disabled in staging. This should match production configuration for accurate testing")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func hasPasswordComplexity(password string) bool <span class="cov8" title="1">{
        hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
        hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
        hasNumber := regexp.MustCompile(`[0-9]`).MatchString(password)
        hasSpecial := regexp.MustCompile(`[!@#$%^&amp;*()_+\-=\[\]{};':"\\|,.&lt;&gt;/?]`).MatchString(password)
        return hasUpper &amp;&amp; hasLower &amp;&amp; hasNumber &amp;&amp; hasSpecial
}</span>

func getEnvAsFloatPtr(key string, defaultValue float64) *float64 <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return &amp;defaultValue
        }</span>
        <span class="cov0" title="0">if floatValue, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                return &amp;floatValue
        }</span>
        <span class="cov0" title="0">return &amp;defaultValue</span>
}

func getEnvAsBoolPtr(key string, defaultValue bool) *bool <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return &amp;defaultValue
        }</span>
        <span class="cov0" title="0">if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                return &amp;boolValue
        }</span>
        <span class="cov0" title="0">return &amp;defaultValue</span>
}

func getEnvAsIntPtr(key string, defaultValue int) *int <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return &amp;defaultValue
        }</span>
        <span class="cov0" title="0">if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                return &amp;intValue
        }</span>
        <span class="cov0" title="0">return &amp;defaultValue</span>
}

func getEnvAsDurationPtr(key string, defaultValue time.Duration) *time.Duration <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return &amp;defaultValue
        }</span>
        <span class="cov0" title="0">if durationValue, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                return &amp;durationValue
        }</span>
        <span class="cov0" title="0">return &amp;defaultValue</span>
}

func getEnvAsFloat(key string, defaultValue float64) float64 <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if floatValue, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                        return floatValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        return intValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov8" title="1">{
                        return boolValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if durationValue, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return durationValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvAsSlice(key string, defaultValue []string) []string <span class="cov8" title="1">{
        valueStr := os.Getenv(key)
        if valueStr == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>

        <span class="cov8" title="1">parts := strings.Split(valueStr, ",")
        result := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                trimmedPart := strings.TrimSpace(part)
                if trimmedPart != "" </span><span class="cov8" title="1">{
                        result = append(result, trimmedPart)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// internal/infrastructure/database/circuit_breaker.go
package database

import (
        "context"
        "database/sql"
        "database/sql/driver"
        "fmt"
        "sync"
        "time"

        "github.com/sony/gobreaker"
        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/database/errors"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "go.uber.org/zap"
)

// DBTX defines the interface needed for database operations
type DBTX interface {
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

// BreakerDB wraps sql.DB with a circuit breaker to prevent cascading failures
type BreakerDB struct {
        *sql.DB
        cb      *gobreaker.CircuitBreaker
        metrics *observability.Metrics
        logger  *observability.Logger
}

// NewBreakerDB creates a new BreakerDB from config
func NewBreakerDB(db *sql.DB, cfg config.CBConfig, metrics *observability.Metrics, logger *observability.Logger) *BreakerDB <span class="cov0" title="0">{
        settings := gobreaker.Settings{
                Name: "MariaDB",
                // MaxRequests is used for half-open state, not max failures
                MaxRequests: uint32(cfg.MaxFailures),
                Interval:    0, // Disable cyclic timer, we'll use ReadyToTrip
                Timeout:     cfg.ResetTimeout,
                ReadyToTrip: func(counts gobreaker.Counts) bool </span><span class="cov0" title="0">{
                        failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
                        return counts.Requests &gt;= 3 &amp;&amp; failureRatio &gt;= cfg.FailureThreshold
                }</span>,
                OnStateChange: func(name string, from gobreaker.State, to gobreaker.State) <span class="cov0" title="0">{
                        defer logger.Sync()
                        logger.Warn(context.Background(), "Circuit breaker state changed",
                                zap.String("db", name),
                                zap.String("from_state", from.String()),
                                zap.String("to_state", to.String()),
                                zap.Time("timestamp", time.Now()),
                        )

                        // Record state as metric (0=closed, 0.5=half_open, 1=open)
                        stateValue := 0.0
                        switch to </span>{
                        case gobreaker.StateOpen:<span class="cov0" title="0">
                                stateValue = 1.0</span>
                        case gobreaker.StateHalfOpen:<span class="cov0" title="0">
                                stateValue = 0.5</span>
                        }
                        <span class="cov0" title="0">if metrics != nil </span><span class="cov0" title="0">{
                                metrics.CircuitBreakerState.WithLabelValues(name, to.String()).Set(stateValue)
                                metrics.CircuitBreakerEvents.WithLabelValues(name, "state_change", from.String()+"_to_"+to.String()).Inc()
                        }</span>
                },
        }

        <span class="cov0" title="0">return &amp;BreakerDB{
                DB:      db,
                cb:      gobreaker.NewCircuitBreaker(settings),
                metrics: metrics,
                logger:  logger,
        }</span>
}

// ExecContext wraps the Exec call in the circuit breaker
func (b *BreakerDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(start).Seconds()
                success := "success"
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        success = "panic"
                }</span>
                <span class="cov0" title="0">if b.metrics != nil </span><span class="cov0" title="0">{
                        b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", success).Observe(duration)
                }</span>
        }()

        <span class="cov0" title="0">result, err := b.cb.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return b.DB.ExecContext(ctx, query, args...)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Only count non-transient errors towards circuit breaker
                if !errors.IsTransientError(err) </span><span class="cov0" title="0">{
                        if b.metrics != nil </span><span class="cov0" title="0">{
                                b.metrics.CircuitBreakerEvents.WithLabelValues("MariaDB", "failure", string(errors.ClassifyError(err))).Inc()
                        }</span>
                }
                <span class="cov0" title="0">if b.metrics != nil </span><span class="cov0" title="0">{
                        b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", "error").Observe(time.Since(start).Seconds())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if b.metrics != nil </span><span class="cov0" title="0">{
                b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", "success").Observe(time.Since(start).Seconds())
        }</span>
        <span class="cov0" title="0">return result.(sql.Result), nil</span>
}

// QueryContext wraps the Query call in the circuit breaker
func (b *BreakerDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(start).Seconds()
                success := "success"
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        success = "panic"
                }</span>
                <span class="cov0" title="0">if b.metrics != nil </span><span class="cov0" title="0">{
                        b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", success).Observe(duration)
                }</span>
        }()

        <span class="cov0" title="0">rows, err := b.cb.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return b.DB.QueryContext(ctx, query, args...)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Only count non-transient errors towards circuit breaker
                if !errors.IsTransientError(err) </span><span class="cov0" title="0">{
                        if b.metrics != nil </span><span class="cov0" title="0">{
                                b.metrics.CircuitBreakerEvents.WithLabelValues("MariaDB", "failure", string(errors.ClassifyError(err))).Inc()
                        }</span>
                }
                <span class="cov0" title="0">if b.metrics != nil </span><span class="cov0" title="0">{
                        b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", "error").Observe(time.Since(start).Seconds())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if b.metrics != nil </span><span class="cov0" title="0">{
                b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", "success").Observe(time.Since(start).Seconds())
        }</span>
        <span class="cov0" title="0">return rows.(*sql.Rows), nil</span>
}

// QueryRowContext wraps the QueryRow call with circuit breaker protection
func (b *BreakerDB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        // First check if circuit is open to fail fast
        if b.cb.State() == gobreaker.StateOpen </span><span class="cov0" title="0">{
                return newErrorRow(gobreaker.ErrOpenState)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(start).Seconds()
                success := "success"
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        success = "panic"
                }</span>
                <span class="cov0" title="0">if b.metrics != nil </span><span class="cov0" title="0">{
                        b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", success).Observe(duration)
                }</span>
        }()

        // Execute within circuit breaker
        <span class="cov0" title="0">result, err := b.cb.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return b.DB.QueryRowContext(ctx, query, args...), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if b.metrics != nil </span><span class="cov0" title="0">{
                        b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", "error").Observe(time.Since(start).Seconds())
                }</span>
                <span class="cov0" title="0">return newErrorRow(err)</span>
        }

        <span class="cov0" title="0">if b.metrics != nil </span><span class="cov0" title="0">{
                b.metrics.CircuitBreakerDuration.WithLabelValues("MariaDB", "success").Observe(time.Since(start).Seconds())
        }</span>
        <span class="cov0" title="0">return result.(*sql.Row)</span>
}

// PrepareContext passes through to the underlying DB connection
// This doesn't use the circuit breaker because preparing a statement
// doesn't actually execute against the database
func (b *BreakerDB) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        return b.DB.PrepareContext(ctx, query)
}</span>

var (
        faultDB       *sql.DB
        faultOnce     sync.Once
        errorRegistry sync.Map
)

// initFaultDB initializes a singleton DB connection that always fails
func initFaultDB() <span class="cov0" title="0">{
        faultOnce.Do(func() </span><span class="cov0" title="0">{
                sql.Register("fault_injector", &amp;faultDriver{})
                // Open the DB once. The DSN doesn't matter for our driver.
                var err error
                faultDB, err = sql.Open("fault_injector", "")
                if err != nil </span><span class="cov0" title="0">{
                        // This should never happen with our mock driver
                        panic(fmt.Sprintf("failed to initialize fault driver: %v", err))</span>
                }
        })
}

// newErrorRow returns a *sql.Row that will yield the provided error when Scanned.
// It uses a custom driver to avoid using reflection on internal sql.Row fields.
func newErrorRow(err error) *sql.Row <span class="cov0" title="0">{
        initFaultDB()

        // Generate a unique token for this error
        token := fmt.Sprintf("%d", time.Now().UnixNano())
        errorRegistry.Store(token, err)

        // Schedule cleanup (since we don't know when Scan() finishes)
        time.AfterFunc(1*time.Minute, func() </span><span class="cov0" title="0">{
                errorRegistry.Delete(token)
        }</span>)

        // db.QueryRow calls the driver's Prepare/Query.
        // We pass the token as the query string.
        // The driver will look up the error and return it.
        <span class="cov0" title="0">return faultDB.QueryRow(token)</span>
}

type faultDriver struct{}

func (d *faultDriver) Open(name string) (driver.Conn, error) <span class="cov0" title="0">{
        return &amp;faultConn{}, nil
}</span>

type faultConn struct{}

func (c *faultConn) Prepare(query string) (driver.Stmt, error) <span class="cov0" title="0">{
        // The query string is our error token
        if val, ok := errorRegistry.Load(query); ok </span><span class="cov0" title="0">{
                if err, ok := val.(error); ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown fault error")</span>
}

func (c *faultConn) Close() error              <span class="cov0" title="0">{ return nil }</span>
func (c *faultConn) Begin() (driver.Tx, error) <span class="cov0" title="0">{ return nil, fmt.Errorf("not supported") }</span>

// GetState returns the current state of the circuit breaker
func (b *BreakerDB) GetState() gobreaker.State <span class="cov0" title="0">{
        return b.cb.State()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package errors

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/go-sql-driver/mysql"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "go.uber.org/zap"
)

type DBErrorType string

const (
        ErrorTypeDeadlock            DBErrorType = "deadlock"
        ErrorTypeConnectionTimeout   DBErrorType = "connection_timeout"
        ErrorTypeConnectionRefused   DBErrorType = "connection_refused"
        ErrorTypeConstraintViolation DBErrorType = "constraint_violation"
        ErrorTypeDuplicateKey        DBErrorType = "duplicate_key"
        ErrorTypeForeignKeyViolation DBErrorType = "foreign_key_violation"
        ErrorTypeQueryTimeout        DBErrorType = "query_timeout"
        ErrorTypeUnknown             DBErrorType = "unknown"
)

type Classifyable interface {
        Classify() DBErrorType
        Error() string
}

type DBError struct {
        Original error
        Type     DBErrorType
        Context  map[string]interface{}
}

func (e *DBError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("database error: %s (%s)", e.Type, e.Original.Error())
}</span>

func (e *DBError) Classify() DBErrorType <span class="cov0" title="0">{
        return e.Type
}</span>

func (e *DBError) Unwrap() error <span class="cov0" title="0">{
        return e.Original
}</span>

func NewDBError(err error, errType DBErrorType, ctx map[string]interface{}) *DBError <span class="cov0" title="0">{
        return &amp;DBError{
                Original: err,
                Type:     errType,
                Context:  ctx,
        }
}</span>

func ClassifyError(err error) DBErrorType <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Check for context errors first
        <span class="cov8" title="1">if err == context.DeadlineExceeded </span><span class="cov8" title="1">{
                return ErrorTypeQueryTimeout
        }</span>
        <span class="cov8" title="1">if err == context.Canceled </span><span class="cov0" title="0">{
                return ErrorTypeQueryTimeout
        }</span>

        // Check for standard SQL errors
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return ErrorTypeUnknown
        }</span>
        <span class="cov8" title="1">if err == sql.ErrConnDone </span><span class="cov0" title="0">{
                return ErrorTypeConnectionRefused
        }</span>

        // Check for MySQL specific errors
        <span class="cov8" title="1">mysqlErr, ok := err.(*mysql.MySQLError)
        if !ok </span><span class="cov8" title="1">{
                return ErrorTypeUnknown
        }</span>

        <span class="cov8" title="1">switch mysqlErr.Number </span>{
        case 1213:<span class="cov8" title="1"> // Deadlock
                return ErrorTypeDeadlock</span>
        case 1205:<span class="cov0" title="0"> // Lock wait timeout
                return ErrorTypeDeadlock</span>
        case 2003, 2005:<span class="cov8" title="1"> // Connection refused
                return ErrorTypeConnectionRefused</span>
        case 2013:<span class="cov8" title="1"> // Lost connection during query
                return ErrorTypeConnectionTimeout</span>
        case 1062:<span class="cov8" title="1"> // Duplicate key
                return ErrorTypeDuplicateKey</span>
        case 1451, 1452:<span class="cov8" title="1"> // Foreign key violation
                return ErrorTypeForeignKeyViolation</span>
        case 1048, 1146:<span class="cov0" title="0"> // Null value constraint, table not found
                return ErrorTypeConstraintViolation</span>
        case 1206:<span class="cov0" title="0"> // Lock table full
                return ErrorTypeDeadlock</span>
        case 3024:<span class="cov0" title="0"> // Query execution timeout
                return ErrorTypeQueryTimeout</span>
        }

        <span class="cov8" title="1">return ErrorTypeUnknown</span>
}

func IsTransientError(err error) bool <span class="cov8" title="1">{
        errType := ClassifyError(err)
        switch errType </span>{
        case ErrorTypeDeadlock, ErrorTypeConnectionTimeout, ErrorTypeConnectionRefused, ErrorTypeQueryTimeout:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func LogDBError(logger *observability.Logger, err error, operation, query string) <span class="cov0" title="0">{
        dbErr := &amp;DBError{
                Original: err,
                Type:     ClassifyError(err),
                Context: map[string]interface{}{
                        "operation": operation,
                        "query":     query,
                },
        }

        fields := []zap.Field{
                logger.Field("error_type", dbErr.Type),
                logger.Field("original_error", dbErr.Original.Error()),
                logger.Field("operation", operation),
                logger.Field("query", query),
        }

        if dbErr.Type == ErrorTypeDeadlock || dbErr.Type == ErrorTypeQueryTimeout </span><span class="cov0" title="0">{
                logger.Warn(context.Background(), "Transient database error", fields...)
        }</span> else<span class="cov0" title="0"> {
                logger.Error(context.Background(), "Persistent database error", fields...)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package errors

import (
        "context"
        "database/sql"
        "time"

        "github.com/cenkalti/backoff/v4"
        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
)

type RetryConfig struct {
        Enabled           bool
        MaxRetries        int
        InitialInterval   time.Duration
        MaxInterval       time.Duration
        Multiplier        float64
        Randomization     float64
        FatalErrorTypes   []DBErrorType
        TransientErrorFN  func(error) bool
        OperationTimeHook func(operation string, duration time.Duration, attempt uint64)
}

func DefaultRetryConfig() *RetryConfig <span class="cov8" title="1">{
        return &amp;RetryConfig{
                Enabled:         true,
                MaxRetries:      3,
                InitialInterval: 100 * time.Millisecond,
                MaxInterval:     2 * time.Second,
                Multiplier:      2.0,
                Randomization:   0.2,
                FatalErrorTypes: []DBErrorType{
                        ErrorTypeConstraintViolation,
                        ErrorTypeDuplicateKey,
                        ErrorTypeForeignKeyViolation,
                },
                TransientErrorFN: IsTransientError,
        }
}</span>

func (cfg *RetryConfig) MergeWith(config *config.DatabaseRetryConfig) *RetryConfig <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return cfg
        }</span>

        <span class="cov8" title="1">if config.Enabled != nil </span><span class="cov8" title="1">{
                cfg.Enabled = *config.Enabled
        }</span>
        <span class="cov8" title="1">if config.MaxRetries != nil </span><span class="cov8" title="1">{
                cfg.MaxRetries = *config.MaxRetries
        }</span>
        <span class="cov8" title="1">if config.InitialInterval != nil </span><span class="cov8" title="1">{
                cfg.InitialInterval = *config.InitialInterval
        }</span>
        <span class="cov8" title="1">if config.MaxInterval != nil </span><span class="cov8" title="1">{
                cfg.MaxInterval = *config.MaxInterval
        }</span>
        <span class="cov8" title="1">if config.Multiplier != nil </span><span class="cov8" title="1">{
                cfg.Multiplier = *config.Multiplier
        }</span>
        <span class="cov8" title="1">if config.Randomization != nil </span><span class="cov8" title="1">{
                cfg.Randomization = *config.Randomization
        }</span>
        <span class="cov8" title="1">if len(config.FatalErrorTypes) &gt; 0 </span><span class="cov8" title="1">{
                cfg.FatalErrorTypes = make([]DBErrorType, len(config.FatalErrorTypes))
                for i, errType := range config.FatalErrorTypes </span><span class="cov8" title="1">{
                        cfg.FatalErrorTypes[i] = DBErrorType(errType)
                }</span>
        }

        <span class="cov8" title="1">return cfg</span>
}

func (cfg *RetryConfig) IsFatalError(err error) bool <span class="cov8" title="1">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">errType := ClassifyError(err)
        for _, fatalType := range cfg.FatalErrorTypes </span><span class="cov8" title="1">{
                if errType == fatalType </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (cfg *RetryConfig) ShouldRetry(err error) bool <span class="cov8" title="1">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if cfg.IsFatalError(err) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if cfg.TransientErrorFN != nil </span><span class="cov8" title="1">{
                return cfg.TransientErrorFN(err)
        }</span>

        <span class="cov0" title="0">return IsTransientError(err)</span>
}

type RetryableFunc func(attempt uint64) error

func RetryOperation(ctx context.Context, operationName string, f RetryableFunc, cfg *RetryConfig, metrics *observability.Metrics, logger *observability.Logger) error <span class="cov8" title="1">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                return f(0)
        }</span>

        <span class="cov8" title="1">expBackoff := backoff.NewExponentialBackOff()
        expBackoff.InitialInterval = cfg.InitialInterval
        expBackoff.MaxInterval = cfg.MaxInterval
        expBackoff.Multiplier = cfg.Multiplier
        expBackoff.RandomizationFactor = cfg.Randomization
        expBackoff.MaxElapsedTime = 0 // No maximum elapsed time, controlled by MaxRetries
        expBackoff.Reset()

        startTime := time.Now()
        var attempt uint64 = 0
        var lastErr error

        for </span><span class="cov8" title="1">{
                attempt++
                lastErr = f(attempt)

                if lastErr == nil </span><span class="cov8" title="1">{
                        if attempt &gt; 1 &amp;&amp; cfg.OperationTimeHook != nil </span><span class="cov0" title="0">{
                                duration := time.Since(startTime)
                                cfg.OperationTimeHook(operationName, duration, attempt)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">if !cfg.ShouldRetry(lastErr) </span><span class="cov8" title="1">{
                        if metrics != nil </span><span class="cov8" title="1">{
                                metrics.DatabaseRetrySkipped.WithLabelValues(operationName, string(ClassifyError(lastErr))).Inc()
                        }</span>
                        <span class="cov8" title="1">return lastErr</span>
                }

                <span class="cov8" title="1">if attempt &gt;= uint64(cfg.MaxRetries) </span><span class="cov8" title="1">{
                        if metrics != nil </span><span class="cov8" title="1">{
                                metrics.DatabaseRetryMaxAttempts.WithLabelValues(operationName).Inc()
                        }</span>
                        <span class="cov8" title="1">return lastErr</span>
                }

                <span class="cov8" title="1">if metrics != nil </span><span class="cov8" title="1">{
                        metrics.DatabaseRetryAttempts.WithLabelValues(operationName, string(ClassifyError(lastErr))).Inc()
                }</span>

                <span class="cov8" title="1">if logger != nil </span><span class="cov8" title="1">{
                        logger.Warn(ctx, "Retrying database operation",
                                logger.Field("operation", operationName),
                                logger.Field("attempt", attempt),
                                logger.Field("max_attempts", cfg.MaxRetries),
                                logger.Field("error", lastErr.Error()),
                        )
                }</span>

                <span class="cov8" title="1">nextInterval := expBackoff.NextBackOff()
                select </span>{
                case &lt;-time.After(nextInterval):<span class="cov8" title="1"></span>
                        // Continue to next attempt
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }
}

func WithRetryTx(ctx context.Context, db *sql.DB, fn func(tx *sql.Tx) error, cfg *RetryConfig, metrics *observability.Metrics, logger *observability.Logger) error <span class="cov8" title="1">{
        return RetryOperation(ctx, "transaction", func(attempt uint64) error </span><span class="cov8" title="1">{
                tx, err := db.BeginTx(ctx, &amp;sql.TxOptions{
                        Isolation: sql.LevelReadCommitted,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                        if p := recover(); p != nil </span><span class="cov0" title="0">{
                                _ = tx.Rollback()
                                panic(p)</span>
                        }
                }()

                <span class="cov8" title="1">if err := fn(tx); err != nil </span><span class="cov8" title="1">{
                        rbErr := tx.Rollback()
                        if rbErr != nil </span><span class="cov0" title="0">{
                                return err // Return original error, rollback error is secondary
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }

                <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, cfg, metrics, logger)
}</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/database/errors"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
)

type DB struct {
        *sql.DB
        retryConfig *errors.RetryConfig
        metrics     *observability.Metrics
        logger      *observability.Logger
}

func NewMariaDB(ctx context.Context, cfg *config.DatabaseConfig, metrics *observability.Metrics, logger *observability.Logger) (*DB, error) <span class="cov8" title="1">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true&amp;charset=utf8mb4&amp;collation=utf8mb4_unicode_ci&amp;maxAllowedPacket=67108864&amp;interpolateParams=true&amp;timeout=10s&amp;readTimeout=10s&amp;writeTimeout=10s",
                cfg.User,
                cfg.Password,
                cfg.Host,
                cfg.Port,
                cfg.Name,
        )

        var db *sql.DB
        var err error

        // Initialize retry configuration for connection attempts
        retryCfg := errors.DefaultRetryConfig().MergeWith(&amp;cfg.Retry)

        // Wrap connection logic in retry mechanism
        err = errors.RetryOperation(ctx, "db_connection", func(attempt uint64) error </span><span class="cov8" title="1">{
                var connectErr error
                db, connectErr = sql.Open("mysql", dsn)
                if connectErr != nil </span><span class="cov0" title="0">{
                        return connectErr
                }</span>

                <span class="cov8" title="1">db.SetMaxOpenConns(cfg.MaxOpenConns)
                db.SetMaxIdleConns(cfg.MaxIdleConns)
                db.SetConnMaxLifetime(cfg.ConnMaxLifetime)
                db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime)

                pingCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
                defer cancel()
                connectErr = db.PingContext(pingCtx)
                if connectErr != nil </span><span class="cov8" title="1">{
                        _ = db.Close() // Clean up the failed connection
                        return connectErr
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, retryCfg, metrics, logger)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to database after %d attempts: %w", retryCfg.MaxRetries, err)
        }</span>

        // Create DB wrapper with retry configuration
        <span class="cov0" title="0">return &amp;DB{
                DB:          db,
                retryConfig: retryCfg,
                metrics:     metrics,
                logger:      logger,
        }, nil</span>
}

type TxFunc func(*sql.Tx) error

func (db *DB) WithTx(ctx context.Context, fn TxFunc) error <span class="cov8" title="1">{
        return errors.WithRetryTx(ctx, db.DB, fn, db.retryConfig, db.metrics, db.logger)
}</span>

func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var result sql.Result
        var err error

        err = errors.RetryOperation(ctx, "exec", func(attempt uint64) error </span><span class="cov0" title="0">{
                start := time.Now()
                result, err = db.DB.ExecContext(ctx, query, args...)
                duration := time.Since(start)

                // Record metrics
                if db.metrics != nil </span><span class="cov0" title="0">{
                        db.metrics.DatabaseQueryDuration.WithLabelValues("exec", "unknown").Observe(duration.Seconds())
                        if err != nil </span><span class="cov0" title="0">{
                                db.metrics.DatabaseQueryErrors.WithLabelValues("exec", "unknown", string(errors.ClassifyError(err))).Inc()
                        }</span> else<span class="cov0" title="0"> {
                                db.metrics.DatabaseQuerySuccess.WithLabelValues("exec", "unknown").Inc()
                        }</span>
                }

                // Log errors
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        errors.LogDBError(db.logger, err, "exec", query)
                }</span>

                <span class="cov0" title="0">return err</span>
        }, db.retryConfig, db.metrics, db.logger)

        <span class="cov0" title="0">return result, err</span>
}

func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        var rows *sql.Rows
        var err error

        err = errors.RetryOperation(ctx, "query", func(attempt uint64) error </span><span class="cov8" title="1">{
                start := time.Now()
                rows, err = db.DB.QueryContext(ctx, query, args...)
                duration := time.Since(start)

                // Record metrics
                if db.metrics != nil </span><span class="cov8" title="1">{
                        db.metrics.DatabaseQueryDuration.WithLabelValues("query", "unknown").Observe(duration.Seconds())
                        if err != nil </span><span class="cov8" title="1">{
                                db.metrics.DatabaseQueryErrors.WithLabelValues("query", "unknown", string(errors.ClassifyError(err))).Inc()
                        }</span> else<span class="cov8" title="1"> {
                                db.metrics.DatabaseQuerySuccess.WithLabelValues("query", "unknown").Inc()
                        }</span>
                }

                // Log errors
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        errors.LogDBError(db.logger, err, "query", query)
                }</span>

                <span class="cov8" title="1">return err</span>
        }, db.retryConfig, db.metrics, db.logger)

        <span class="cov8" title="1">return rows, err</span>
}

func (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        return db.DB.QueryRowContext(ctx, query, args...)
}</span>

func (db *DB) Close() error <span class="cov0" title="0">{
        return db.DB.Close()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "context"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/security"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
        "github.com/waqasmani/go-boilerplate/internal/shared/utils"
)

type AuthMiddleware struct {
        jwtService *security.JWTService
}

func NewAuthMiddleware(jwtService *security.JWTService) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                jwtService: jwtService,
        }
}</span>

func (m *AuthMiddleware) Authenticate() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        utils.Error(c, errors.ErrUnauthorized)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">const bearerPrefix = "Bearer "
                if !strings.HasPrefix(authHeader, bearerPrefix) </span><span class="cov0" title="0">{
                        utils.Error(c, errors.Wrap(errors.ErrUnauthorized, errors.ErrCodeUnauthorized, "Invalid authorization header format"))
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">tokenString := strings.TrimSpace(authHeader[len(bearerPrefix):])
                if tokenString == "" </span><span class="cov0" title="0">{
                        utils.Error(c, errors.Wrap(errors.ErrUnauthorized, errors.ErrCodeUnauthorized, "Missing token"))
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">claims, err := m.jwtService.ValidateAccessToken(c.Request.Context(), tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(c, err)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">ctx := context.WithValue(c.Request.Context(), security.UserIDKey, claims.UserID)
                ctx = context.WithValue(ctx, security.UserRoleKey, claims.Role)
                ctx = context.WithValue(ctx, security.UserEmailKey, claims.Email)
                c.Request = c.Request.WithContext(ctx)

                c.Set(string(security.UserIDKey), claims.UserID)
                c.Set(string(security.UserRoleKey), claims.Role)
                c.Set(string(security.UserEmailKey), claims.Email)

                c.Next()</span>
        }
}

func (m *AuthMiddleware) Authorize(allowedRoles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                userRole, exists := c.Get(string(security.UserRoleKey))
                if !exists </span><span class="cov0" title="0">{
                        utils.Error(c, errors.ErrForbidden)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">role, ok := userRole.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error(c, errors.Wrap(errors.ErrForbidden, errors.ErrCodeInternal, "Invalid role type in context"))
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">hasPermission := false
                for _, allowedRole := range allowedRoles </span><span class="cov0" title="0">{
                        if role == allowedRole </span><span class="cov0" title="0">{
                                hasPermission = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        utils.Error(c, errors.ErrForbidden)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func GetCurrentUserID(c *gin.Context) (uint64, error) <span class="cov0" title="0">{
        userID, exists := c.Get(string(security.UserIDKey))
        if !exists </span><span class="cov0" title="0">{
                return 0, errors.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">id, ok := userID.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return 0, errors.Wrap(errors.ErrUnauthorized, errors.ErrCodeInternal, "Invalid user ID type in context")
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

func GetCurrentUserRole(c *gin.Context) (string, error) <span class="cov0" title="0">{
        userRole, exists := c.Get(string(security.UserRoleKey))
        if !exists </span><span class="cov0" title="0">{
                return "", errors.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">role, ok := userRole.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.Wrap(errors.ErrUnauthorized, errors.ErrCodeInternal, "Invalid role type in context")
        }</span>

        <span class="cov0" title="0">return role, nil</span>
}

// IsAdminOrOwner checks if the authenticated user is either an admin or the owner of the resource
// Returns an error if authorization fails, nil if authorized
func IsAdminOrOwner(c *gin.Context, targetID uint64) error <span class="cov0" title="0">{
        authUserID, err := GetCurrentUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ErrCodeUnauthorized, "Failed to get user ID from context")
        }</span>

        // Owner check - user can access their own resources
        <span class="cov0" title="0">if authUserID == targetID </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Admin check - admins can access any resource
        <span class="cov0" title="0">role, err := GetCurrentUserRole(c)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ErrCodeUnauthorized, "Failed to get user role from context")
        }</span>

        <span class="cov0" title="0">if role == "admin" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Neither owner nor admin
        <span class="cov0" title="0">return errors.New(errors.ErrCodeForbidden, "Access denied: insufficient permissions")</span>
}

// IsAdmin checks if the authenticated user has admin role
func IsAdmin(c *gin.Context) bool <span class="cov0" title="0">{
        role, err := GetCurrentUserRole(c)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return role == "admin"</span>
}

// RequireOwnership ensures the authenticated user is the owner of the resource
// This is stricter than IsAdminOrOwner - even admins are not allowed
func RequireOwnership(c *gin.Context, targetID uint64) error <span class="cov0" title="0">{
        authUserID, err := GetCurrentUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ErrCodeUnauthorized, "Failed to get user ID from context")
        }</span>

        <span class="cov0" title="0">if authUserID != targetID </span><span class="cov0" title="0">{
                return errors.New(errors.ErrCodeForbidden, "Access denied: you can only access your own resources")
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
        "github.com/waqasmani/go-boilerplate/internal/shared/utils"
        "go.uber.org/zap"
)

func ErrorHandlingMiddleware(logger *observability.Logger, metrics *observability.Metrics) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Process any errors that occurred during request handling
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        // Get the last error (most relevant)
                        err := c.Errors.Last().Err

                        // Try to cast to AppError for structured handling
                        appErr, ok := err.(*errors.AppError)
                        if !ok </span><span class="cov0" title="0">{
                                // If not an AppError, wrap it appropriately
                                if c.Writer.Status() &gt;= 500 </span><span class="cov0" title="0">{
                                        appErr = errors.Wrap(err, errors.ErrCodeInternal, "Internal server error")
                                }</span> else<span class="cov0" title="0"> {
                                        appErr = errors.Wrap(err, errors.ErrCodeBadRequest, "Request processing error")
                                }</span>
                        }

                        // Record error metric
                        <span class="cov0" title="0">if metrics != nil </span><span class="cov0" title="0">{
                                metrics.RecordError(appErr.ErrorType, c.Request.Method, c.FullPath())
                        }</span>

                        // Log the error with correlation IDs
                        <span class="cov0" title="0">ctx := c.Request.Context()
                        fields := []zap.Field{
                                logger.Field("path", c.Request.URL.Path),
                                logger.Field("method", c.Request.Method),
                                logger.Field("status_code", c.Writer.Status()),
                                logger.Field("error_type", appErr.ErrorType),
                                logger.Field("error_code", appErr.Code),
                        }

                        if appErr.Err != nil </span><span class="cov0" title="0">{
                                fields = append(fields, logger.Field("original_error", appErr.Err.Error()))
                        }</span>

                        <span class="cov0" title="0">if appErr.Details != nil </span><span class="cov0" title="0">{
                                fields = append(fields, logger.Field("details", appErr.Details))
                        }</span>

                        <span class="cov0" title="0">if appErr.ErrorType == errors.ErrorTypeServer </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Server error occurred", fields...)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Warn(ctx, "Client error occurred", fields...)
                        }</span>

                        // Don't overwrite response if it's already been written
                        <span class="cov0" title="0">if !c.Writer.Written() </span><span class="cov0" title="0">{
                                utils.Error(c, appErr)
                        }</span>
                }
        }
}

func TracingMiddleware(logger *observability.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Extract tracing context from headers
                traceID := c.GetHeader("X-Request-ID")
                if traceID == "" </span><span class="cov0" title="0">{
                        id, _ := uuid.NewRandom()
                        traceID = id.String()
                }</span>

                // Create a new context with trace ID
                <span class="cov0" title="0">ctx := context.WithValue(c.Request.Context(), observability.TraceIDKey, traceID)
                c.Request = c.Request.WithContext(ctx)

                // Log the trace ID for correlation
                logger.Debug(ctx, "Trace started",
                        logger.Field("trace_id", traceID),
                        logger.Field("path", c.Request.URL.Path),
                        logger.Field("method", c.Request.Method),
                )

                c.Next()</span>
        }
}

func RequestIDMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        id, _ := uuid.NewRandom()
                        requestID = id.String()
                }</span>

                <span class="cov0" title="0">ctx := context.WithValue(c.Request.Context(), observability.RequestIDKey, requestID)
                c.Request = c.Request.WithContext(ctx)

                c.Set(string(observability.RequestIDKey), requestID)
                c.Header("X-Request-ID", requestID)

                c.Next()</span>
        }
}

// TimeoutMiddleware attaches a timeout to the request context.
// Downstream handlers (DB, API calls) using this context will automatically cancel if the timeout is reached.
func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
                defer cancel()

                // Update the request with the new context
                c.Request = c.Request.WithContext(ctx)
                c.Next()
        }</span>
}

func NewCORSMiddleware(cfg config.CORSConfig) gin.HandlerFunc <span class="cov0" title="0">{
        corsCfg := cors.Config{
                AllowOrigins:     cfg.AllowedOrigins,
                AllowMethods:     cfg.AllowedMethods,
                AllowHeaders:     append(cfg.AllowedHeaders, "X-CSRF-Token", "X-Request-ID"),
                AllowCredentials: true,
                MaxAge:           24 * time.Hour,
                ExposeHeaders:    []string{"X-Request-ID", "X-RateLimit-Limit", "X-RateLimit-Remaining", "X-RateLimit-Reset", "X-CSRF-Token"},
        }

        for _, origin := range cfg.AllowedOrigins </span><span class="cov0" title="0">{
                if origin == "*" </span><span class="cov0" title="0">{
                        corsCfg.AllowAllOrigins = true
                        corsCfg.AllowOrigins = nil
                        break</span>
                }
        }

        <span class="cov0" title="0">return cors.New(corsCfg)</span>
}

// SecurityHeadersMiddleware injects common security-related HTTP headers.
func SecurityHeadersMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Content-Security-Policy", "default-src 'self'; script-src 'self'; object-src 'none';")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
                c.Header("Permissions-Policy", "geolocation=(), microphone=(), camera=()")

                c.Next()
        }</span>
}

func LoggerMiddleware(logger *observability.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                method := c.Request.Method
                userAgent := c.Request.UserAgent()
                clientIP := c.ClientIP()

                c.Next()

                latency := time.Since(start)
                statusCode := c.Writer.Status()

                fields := []zap.Field{
                        logger.Field("method", method),
                        logger.Field("path", path),
                        logger.Field("status", statusCode),
                        logger.Field("latency_ms", latency.Milliseconds()),
                        logger.Field("client_ip", clientIP),
                        logger.Field("user_agent", userAgent),
                }

                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        fields = append(fields, logger.Field("errors", c.Errors.String()))
                }</span>

                <span class="cov0" title="0">if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        logger.Error(c.Request.Context(), "HTTP Request completed with server error", fields...)
                }</span> else<span class="cov0" title="0"> if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        logger.Warn(c.Request.Context(), "HTTP Request completed with client error", fields...)
                }</span> else<span class="cov0" title="0"> {
                        logger.Info(c.Request.Context(), "HTTP Request completed", fields...)
                }</span>
        }
}

func MetricsMiddleware(metrics *observability.Metrics) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.FullPath()
                if path == "" </span><span class="cov0" title="0">{
                        path = "unknown"
                }</span>
                <span class="cov0" title="0">method := c.Request.Method

                c.Next()

                duration := time.Since(start).Seconds()
                status := fmt.Sprintf("%d", c.Writer.Status())

                metrics.HttpRequestsTotal.WithLabelValues(method, path, status).Inc()
                metrics.HttpRequestDuration.WithLabelValues(method, path).Observe(duration)

                if c.Request.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        metrics.HttpRequestSize.WithLabelValues(method, path).Observe(float64(c.Request.ContentLength))
                }</span>

                <span class="cov0" title="0">responseSize := c.Writer.Size()
                if responseSize &gt; 0 </span><span class="cov0" title="0">{
                        metrics.HttpResponseSize.WithLabelValues(method, path).Observe(float64(responseSize))
                }</span>
        }
}

func PanicRecoveryMiddleware(logger *observability.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                logger.Error(c.Request.Context(), "Panic recovered",
                                        zap.Any("error", err),
                                        zap.String("path", c.Request.URL.Path),
                                        zap.String("method", c.Request.Method),
                                )

                                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                                        "success": false,
                                        "error": gin.H{
                                                "code":    "INTERNAL_ERROR",
                                                "message": "Internal server error",
                                        },
                                })
                        }</span>
                }()
                <span class="cov0" title="0">c.Next()</span>
        }
}

// BodyLimitMiddleware restricts the maximum size of the request body to prevent OOM attacks.
func BodyLimitMiddleware(maxBytes int64) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Use http.MaxBytesReader to enforce the limit at the reader level
                c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, maxBytes)
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package migrations

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"

        _ "github.com/go-sql-driver/mysql"
        "github.com/pressly/goose/v3"
)

// MigrationConfig holds configuration for database migrations
type MigrationConfig struct {
        Dir        string
        DBDriver   string
        DBSource   string
        DirAbsPath string
}

// NewMigrationConfig creates a new MigrationConfig from environment variables
func NewMigrationConfig() (*MigrationConfig, error) <span class="cov0" title="0">{
        dir := getEnv("MIGRATION_DIR", "./migrations")
        dbDriver := getEnv("DB_DRIVER", "mysql")

        // Construct DB source string from environment variables
        dbHost := getEnv("DB_HOST", "localhost")
        dbPort := getEnv("DB_PORT", "3306")
        dbUser := getEnv("DB_USER", "auth_user")
        dbPass := getEnv("DB_PASSWORD", "")
        dbName := getEnv("DB_NAME", "auth_db")

        dbSource := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true",
                dbUser, dbPass, dbHost, dbPort, dbName)

        absPath, err := filepath.Abs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get absolute path for migration directory: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;MigrationConfig{
                Dir:        dir,
                DBDriver:   dbDriver,
                DBSource:   dbSource,
                DirAbsPath: absPath,
        }, nil</span>
}

// InitDB initializes and returns a database connection for migrations
func (cfg *MigrationConfig) InitDB() (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open(cfg.DBDriver, cfg.DBSource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database connection: %w", err)
        }</span>

        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// RunMigrations applies all pending migrations
func (cfg *MigrationConfig) RunMigrations() error <span class="cov0" title="0">{
        db, err := cfg.InitDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer db.Close()

        return goose.Up(db, cfg.Dir)</span>
}

// GetMigrationStatus returns the status of all migrations
func (cfg *MigrationConfig) GetMigrationStatus() error <span class="cov0" title="0">{
        db, err := cfg.InitDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer db.Close()

        return goose.Status(db, cfg.Dir)</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// internal/infrastructure/observability/audit.go
package observability

import (
        "context"
        "os"
        "sync"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type AuditLogger struct {
        logger      *Logger
        file        *os.File
        mu          sync.Mutex
        isDedicated bool
}
type SecurityEvent struct {
        Type      string
        Action    string
        UserID    uint64
        Resource  string
        Success   bool
        IPAddress string
}

// NewAuditLogger creates an audit logger instance
func NewAuditLogger(logger *Logger) *AuditLogger <span class="cov8" title="1">{
        return &amp;AuditLogger{
                logger: logger,
        }
}</span>

// NewDedicatedAuditLogger creates an audit logger that writes to a separate file
func NewDedicatedAuditLogger(filePath, format string) (*AuditLogger, error) <span class="cov0" title="0">{
        // Create file if it doesn't exist, append if it does
        file, err := os.OpenFile(filePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0640)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create zap encoder
        <span class="cov0" title="0">var encoder zapcore.Encoder
        if format == "console" </span><span class="cov0" title="0">{
                encoderConfig := zap.NewDevelopmentEncoderConfig()
                encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
                encoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
                encoder = zapcore.NewConsoleEncoder(encoderConfig)
        }</span> else<span class="cov0" title="0"> {
                // SIEM-friendly JSON format
                encoderConfig := zap.NewProductionEncoderConfig()
                encoderConfig.TimeKey = "timestamp"
                encoderConfig.EncodeTime = zapcore.RFC3339NanoTimeEncoder
                encoderConfig.LevelKey = "level"
                encoderConfig.NameKey = "logger"
                encoderConfig.CallerKey = "caller"
                encoderConfig.MessageKey = "message"
                encoderConfig.StacktraceKey = "stack"
                encoderConfig.LineEnding = zapcore.DefaultLineEnding
                encoderConfig.EncodeDuration = zapcore.SecondsDurationEncoder
                encoderConfig.EncodeCaller = zapcore.ShortCallerEncoder
                encoder = zapcore.NewJSONEncoder(encoderConfig)
        }</span>

        // Create core that writes to our file
        <span class="cov0" title="0">core := zapcore.NewCore(
                encoder,
                zapcore.AddSync(file),
                zapcore.InfoLevel, // Always capture audit events
        )

        // Create the dedicated logger
        zapLogger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))
        dedicatedLogger := &amp;Logger{zap: zapLogger}

        return &amp;AuditLogger{
                logger:      dedicatedLogger,
                file:        file,
                isDedicated: true,
        }, nil</span>
}

// Close releases any resources held by the audit logger
func (a *AuditLogger) Close() error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        if a.file != nil </span><span class="cov0" title="0">{
                err := a.file.Close()
                a.file = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// LogSecurityEvent logs a security-relevant event with structured data
func (a *AuditLogger) LogSecurityEvent(ctx context.Context, event SecurityEvent) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        a.logger.Info(ctx, "AUDIT",
                zap.String("event_type", event.Type),
                zap.Uint64("user_id", event.UserID),
                zap.String("action", event.Action),
                zap.String("resource", event.Resource),
                zap.Bool("success", event.Success),
                zap.String("ip_address", event.IPAddress),
                zap.Time("event_time", time.Now().UTC()), // Explicit UTC timestamp for SIEM
                zap.String("audit_version", "1.0"),
        )
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package observability

import (
        "context"
        "runtime"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type contextKey string

const (
        RequestIDKey contextKey = "request_id"
        UserIDKey    contextKey = "user_id"
        TraceIDKey   contextKey = "trace_id"
        SessionIDKey contextKey = "session_id"
)

type Logger struct {
        zap *zap.Logger
}

func NewLogger(level string, encoding string) (*Logger, error) <span class="cov8" title="1">{
        cfg := zap.NewProductionConfig()

        if encoding == "console" </span><span class="cov8" title="1">{
                cfg.Encoding = "console"
                cfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
                cfg.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
        }</span>

        <span class="cov8" title="1">var zapLevel zapcore.Level
        if err := zapLevel.UnmarshalText([]byte(level)); err != nil </span><span class="cov8" title="1">{
                zapLevel = zapcore.InfoLevel
        }</span>
        <span class="cov8" title="1">cfg.Level.SetLevel(zapLevel)

        cfg.EncoderConfig.CallerKey = "caller"
        cfg.EncoderConfig.EncodeCaller = zapcore.ShortCallerEncoder

        logger, err := cfg.Build(zap.AddCallerSkip(1))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Logger{zap: logger}, nil</span>
}

func (l *Logger) Info(ctx context.Context, msg string, fields ...zap.Field) <span class="cov8" title="1">{
        l.zap.Info(msg, append(l.contextFields(ctx), fields...)...)
}</span>

func (l *Logger) Error(ctx context.Context, msg string, fields ...zap.Field) <span class="cov8" title="1">{
        fields = append(fields, zap.Stack("stack"))
        l.zap.Error(msg, append(l.contextFields(ctx), fields...)...)
}</span>

func (l *Logger) Warn(ctx context.Context, msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.zap.Warn(msg, append(l.contextFields(ctx), fields...)...)
}</span>

func (l *Logger) Debug(ctx context.Context, msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.zap.Debug(msg, append(l.contextFields(ctx), fields...)...)
}</span>

func (l *Logger) Fatal(ctx context.Context, msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.zap.Fatal(msg, append(l.contextFields(ctx), fields...)...)
}</span>

func (l *Logger) WithContext(ctx context.Context, keysAndValues ...interface{}) context.Context <span class="cov0" title="0">{
        for i := 0; i &lt; len(keysAndValues); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keysAndValues) </span><span class="cov0" title="0">{
                        key, ok := keysAndValues[i].(contextKey)
                        if ok </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, key, keysAndValues[i+1])
                        }</span>
                }
        }
        <span class="cov0" title="0">return ctx</span>
}

func (l *Logger) contextFields(ctx context.Context) []zap.Field <span class="cov8" title="1">{
        fields := make([]zap.Field, 0, 5)

        if requestID, ok := ctx.Value(RequestIDKey).(string); ok </span><span class="cov8" title="1">{
                fields = append(fields, zap.String("request_id", requestID))
        }</span>

        <span class="cov8" title="1">if userID, ok := ctx.Value(UserIDKey).(uint64); ok </span><span class="cov8" title="1">{
                fields = append(fields, zap.Uint64("user_id", userID))
        }</span>

        <span class="cov8" title="1">if traceID, ok := ctx.Value(TraceIDKey).(string); ok </span><span class="cov0" title="0">{
                fields = append(fields, zap.String("trace_id", traceID))
        }</span>

        <span class="cov8" title="1">if sessionID, ok := ctx.Value(SessionIDKey).(string); ok </span><span class="cov0" title="0">{
                fields = append(fields, zap.String("session_id", sessionID))
        }</span>

        <span class="cov8" title="1">pc, file, line, ok := runtime.Caller(2)
        if ok </span><span class="cov8" title="1">{
                funcName := runtime.FuncForPC(pc).Name()
                fields = append(fields, zap.String("caller", funcName))
                fields = append(fields, zap.String("file", file))
                fields = append(fields, zap.Int("line", line))
        }</span>

        <span class="cov8" title="1">return fields</span>
}

func (l *Logger) Sync() error <span class="cov8" title="1">{
        return l.zap.Sync()
}</span>

func (l *Logger) Field(key string, value interface{}) zap.Field <span class="cov0" title="0">{
        return zap.Any(key, value)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package observability

import (
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
)

// MetricsConfig holds configuration for metrics initialization
type MetricsConfig struct {
        Namespace string
        Subsystem string
        Registry  prometheus.Registerer
        Gatherer  prometheus.Gatherer
}

// DefaultMetricsConfig returns a config using the default Prometheus registry
func DefaultMetricsConfig() MetricsConfig <span class="cov8" title="1">{
        return MetricsConfig{
                Namespace: "api",
                Subsystem: "",
                Registry:  prometheus.DefaultRegisterer,
                Gatherer:  prometheus.DefaultGatherer,
        }
}</span>

// Metrics holds all Prometheus metrics collectors
type Metrics struct {
        HttpRequestsTotal        *prometheus.CounterVec
        HttpRequestDuration      *prometheus.HistogramVec
        HttpRequestSize          *prometheus.HistogramVec
        HttpResponseSize         *prometheus.HistogramVec
        DatabaseQueryDuration    *prometheus.HistogramVec
        DatabaseQuerySuccess     *prometheus.CounterVec
        DatabaseQueryErrors      *prometheus.CounterVec
        DatabaseConnections      *prometheus.GaugeVec
        DatabaseRetryAttempts    *prometheus.CounterVec
        DatabaseRetrySkipped     *prometheus.CounterVec
        DatabaseRetryMaxAttempts *prometheus.CounterVec
        CacheHits                *prometheus.CounterVec
        CacheMisses              *prometheus.CounterVec
        AuthenticationAttempts   *prometheus.CounterVec
        AuthenticationFailures   *prometheus.CounterVec
        TokenRefreshes           *prometheus.CounterVec
        CSRFValidations          *prometheus.CounterVec
        RateLimitHits            *prometheus.CounterVec
        ActiveSessions           prometheus.Gauge
        BackgroundJobDuration    *prometheus.HistogramVec
        BackgroundJobErrors      *prometheus.CounterVec
        ErrorCount               *prometheus.CounterVec
        ClientErrorCount         *prometheus.CounterVec
        ServerErrorCount         *prometheus.CounterVec
        NetworkErrorCount        *prometheus.CounterVec
        CircuitBreakerState      *prometheus.GaugeVec
        CircuitBreakerEvents     *prometheus.CounterVec
        CircuitBreakerDuration   *prometheus.SummaryVec
        CheckInsTotal            *prometheus.CounterVec
        CheckOutsTotal           *prometheus.CounterVec
        TimeOffRequestsTotal     *prometheus.CounterVec
        AttendanceDuration       *prometheus.HistogramVec
        registry                 prometheus.Registerer
        gatherer                 prometheus.Gatherer
}

var (
        metrics     *Metrics
        metricsOnce sync.Once
)

// NewMetrics creates a new Metrics instance with the provided configuration
func NewMetrics() *Metrics <span class="cov0" title="0">{
        metricsOnce.Do(func() </span><span class="cov0" title="0">{
                metrics = NewMetricsWithConfig(DefaultMetricsConfig())
        }</span>)
        <span class="cov0" title="0">return metrics</span>
}

// NewMetricsWithConfig creates a new Metrics instance with custom configuration
func NewMetricsWithConfig(cfg MetricsConfig) *Metrics <span class="cov8" title="1">{
        // Create a factory with the custom registry
        factory := promauto.With(cfg.Registry)
        m := &amp;Metrics{
                registry: cfg.Registry,
                gatherer: cfg.Gatherer,
        }

        // HTTP Metrics
        m.HttpRequestsTotal = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "http_requests_total",
                        Help:      "Total number of HTTP requests",
                },
                []string{"method", "path", "status"},
        )
        m.HttpRequestDuration = factory.NewHistogramVec(
                prometheus.HistogramOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "http_request_duration_seconds",
                        Help:      "Duration of HTTP requests in seconds",
                        Buckets:   []float64{.001, .005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
                },
                []string{"method", "path"},
        )
        m.HttpRequestSize = factory.NewHistogramVec(
                prometheus.HistogramOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "http_request_size_bytes",
                        Help:      "Size of HTTP requests in bytes",
                        Buckets:   prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"method", "path"},
        )
        m.HttpResponseSize = factory.NewHistogramVec(
                prometheus.HistogramOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "http_response_size_bytes",
                        Help:      "Size of HTTP responses in bytes",
                        Buckets:   prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"method", "path"},
        )

        // Database Metrics
        m.DatabaseQueryDuration = factory.NewHistogramVec(
                prometheus.HistogramOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "database_query_duration_seconds",
                        Help:      "Duration of database queries in seconds",
                        Buckets:   []float64{.001, .005, .01, .025, .05, .1, .25, .5, 1},
                },
                []string{"query_type", "table"},
        )
        m.DatabaseQuerySuccess = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "database_query_success_total",
                        Help:      "Total number of successful database queries",
                },
                []string{"query_type", "table"},
        )
        m.DatabaseQueryErrors = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "database_query_errors_total",
                        Help:      "Total number of database query errors",
                },
                []string{"query_type", "table", "error_type"},
        )
        m.DatabaseConnections = factory.NewGaugeVec(
                prometheus.GaugeOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "database_connections",
                        Help:      "Number of active database connections",
                },
                []string{"state"},
        )
        m.DatabaseRetryAttempts = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "database_retry_attempts_total",
                        Help:      "Total number of database operation retry attempts",
                },
                []string{"operation", "error_type"},
        )
        m.DatabaseRetrySkipped = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "database_retry_skipped_total",
                        Help:      "Total number of database operations that were not retried due to error type",
                },
                []string{"operation", "error_type"},
        )
        m.DatabaseRetryMaxAttempts = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "database_retry_max_attempts_total",
                        Help:      "Total number of database operations that reached max retry attempts",
                },
                []string{"operation"},
        )

        // Cache Metrics
        m.CacheHits = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "cache_hits_total",
                        Help:      "Total number of cache hits",
                },
                []string{"cache_name"},
        )
        m.CacheMisses = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "cache_misses_total",
                        Help:      "Total number of cache misses",
                },
                []string{"cache_name"},
        )

        // Authentication Metrics
        m.AuthenticationAttempts = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "authentication_attempts_total",
                        Help:      "Total number of authentication attempts",
                },
                []string{"method"},
        )
        m.AuthenticationFailures = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "authentication_failures_total",
                        Help:      "Total number of authentication failures",
                },
                []string{"method", "reason"},
        )
        m.TokenRefreshes = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "token_refreshes_total",
                        Help:      "Total number of token refreshes",
                },
                []string{"status"},
        )
        m.CSRFValidations = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "csrf_validations_total",
                        Help:      "Total number of CSRF validations",
                },
                []string{"status"},
        )

        // Rate Limiting Metrics
        m.RateLimitHits = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "rate_limit_hits_total",
                        Help:      "Total number of rate limit hits",
                },
                []string{"route", "identifier"},
        )
        m.ActiveSessions = factory.NewGauge(
                prometheus.GaugeOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "active_sessions",
                        Help:      "Number of active user sessions",
                },
        )

        // Background Job Metrics
        m.BackgroundJobDuration = factory.NewHistogramVec(
                prometheus.HistogramOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "background_job_duration_seconds",
                        Help:      "Duration of background jobs in seconds",
                        Buckets:   []float64{.1, .5, 1, 5, 10, 30, 60, 300},
                },
                []string{"job_name"},
        )
        m.BackgroundJobErrors = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "background_job_errors_total",
                        Help:      "Total number of background job errors",
                },
                []string{"job_name", "error_type"},
        )

        // Error Metrics
        m.ErrorCount = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "error_total",
                        Help:      "Total number of errors by type",
                },
                []string{"error_type", "method", "path"},
        )
        m.ClientErrorCount = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "client_error_total",
                        Help:      "Total number of client errors",
                },
                []string{"error_code", "method", "path"},
        )
        m.ServerErrorCount = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "server_error_total",
                        Help:      "Total number of server errors",
                },
                []string{"error_code", "method", "path"},
        )
        m.NetworkErrorCount = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "network_error_total",
                        Help:      "Total number of network errors",
                },
                []string{"error_code", "method", "path"},
        )

        // Circuit Breaker Metrics
        m.CircuitBreakerState = factory.NewGaugeVec(
                prometheus.GaugeOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "circuit_breaker_state",
                        Help:      "Current state of circuit breakers (0=closed, 0.5=half_open, 1=open)",
                },
                []string{"name", "state"},
        )
        m.CircuitBreakerEvents = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: cfg.Namespace,
                        Subsystem: cfg.Subsystem,
                        Name:      "circuit_breaker_events_total",
                        Help:      "Total number of circuit breaker events",
                },
                []string{"name", "event_type", "reason"},
        )
        m.CircuitBreakerDuration = factory.NewSummaryVec(
                prometheus.SummaryOpts{
                        Namespace:  cfg.Namespace,
                        Subsystem:  cfg.Subsystem,
                        Name:       "circuit_breaker_duration_seconds",
                        Help:       "Duration of operations protected by circuit breakers",
                        Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
                },
                []string{"name", "status"},
        )

        // Attendance Metrics
        m.CheckInsTotal = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "attendance_check_ins_total",
                        Help: "Total number of check-ins",
                },
                []string{"status"},
        )

        m.CheckOutsTotal = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "attendance_check_outs_total",
                        Help: "Total number of check-outs",
                },
                []string{"status"},
        )

        m.TimeOffRequestsTotal = factory.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "time_off_requests_total",
                        Help: "Total time off requests",
                },
                []string{"leave_type", "status"},
        )

        m.AttendanceDuration = factory.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "attendance_duration_seconds",
                        Help:    "Distribution of attendance session durations",
                        Buckets: prometheus.ExponentialBuckets(3600, 2, 10),
                },
                []string{"shift"},
        )

        return m
}</span>

// RecordDatabaseStats records database connection pool statistics
func (m *Metrics) RecordDatabaseStats(openConns, inUse, idle int) <span class="cov8" title="1">{
        m.DatabaseConnections.WithLabelValues("open").Set(float64(openConns))
        m.DatabaseConnections.WithLabelValues("in_use").Set(float64(inUse))
        m.DatabaseConnections.WithLabelValues("idle").Set(float64(idle))
}</span>

// RecordBackgroundJob records metrics for background job execution
func (m *Metrics) RecordBackgroundJob(jobName string, duration time.Duration, err error) <span class="cov8" title="1">{
        m.BackgroundJobDuration.WithLabelValues(jobName).Observe(duration.Seconds())
        if err != nil </span><span class="cov8" title="1">{
                m.BackgroundJobErrors.WithLabelValues(jobName, "error").Inc()
        }</span>
}

// RecordError records error metrics by type
func (m *Metrics) RecordError(errorType errors.ErrorType, method, path string) <span class="cov8" title="1">{
        m.ErrorCount.WithLabelValues(string(errorType), method, path).Inc()
        // Record specific error type metrics for better granularity
        switch errorType </span>{
        case errors.ErrorTypeClient:<span class="cov8" title="1">
                m.ClientErrorCount.WithLabelValues("client_error", method, path).Inc()</span>
        case errors.ErrorTypeServer:<span class="cov8" title="1">
                m.ServerErrorCount.WithLabelValues("server_error", method, path).Inc()</span>
        case errors.ErrorTypeNetwork:<span class="cov8" title="1">
                m.NetworkErrorCount.WithLabelValues("network_error", method, path).Inc()</span>
        }
}

// Registry returns the Prometheus registry used by this Metrics instance
func (m *Metrics) Registry() prometheus.Registerer <span class="cov0" title="0">{
        return m.registry
}</span>

// Gatherer returns the Prometheus gatherer used by this Metrics instance
func (m *Metrics) Gatherer() prometheus.Gatherer <span class="cov8" title="1">{
        return m.gatherer
}</span>

// Unregister removes all metrics from the registry
// Useful for testing to prevent metric collisions
func (m *Metrics) Unregister() <span class="cov8" title="1">{
        if m.registry == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">collectors := []prometheus.Collector{
                m.HttpRequestsTotal,
                m.HttpRequestDuration,
                m.HttpRequestSize,
                m.HttpResponseSize,
                m.DatabaseQueryDuration,
                m.DatabaseQuerySuccess,
                m.DatabaseQueryErrors,
                m.DatabaseConnections,
                m.DatabaseRetryAttempts,
                m.DatabaseRetrySkipped,
                m.DatabaseRetryMaxAttempts,
                m.CacheHits,
                m.CacheMisses,
                m.AuthenticationAttempts,
                m.AuthenticationFailures,
                m.TokenRefreshes,
                m.CSRFValidations,
                m.RateLimitHits,
                m.ActiveSessions,
                m.BackgroundJobDuration,
                m.BackgroundJobErrors,
                m.ErrorCount,
                m.ClientErrorCount,
                m.ServerErrorCount,
                m.NetworkErrorCount,
                m.CircuitBreakerState,
                m.CircuitBreakerEvents,
                m.CircuitBreakerDuration,
                m.CheckInsTotal,
                m.CheckOutsTotal,
                m.TimeOffRequestsTotal,
                m.AttendanceDuration,
        }
        for _, collector := range collectors </span><span class="cov8" title="1">{
                m.registry.Unregister(collector)
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package observability

import (
        "context"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/trace"
)

type Tracer struct {
        tracer trace.Tracer
}

func NewTracer(serviceName string) *Tracer <span class="cov8" title="1">{
        return &amp;Tracer{
                tracer: otel.Tracer(serviceName),
        }
}</span>

func (t *Tracer) Start(ctx context.Context, spanName string) (context.Context, trace.Span) <span class="cov8" title="1">{
        return t.tracer.Start(ctx, spanName)
}</pre>
		
		<pre class="file" id="file18" style="display: none">package security

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "slices"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
)

type JWTService struct {
        accessSecret  []byte
        accessExpiry  time.Duration
        refreshExpiry time.Duration
        issuer        string
        audience      string
}

type Claims struct {
        UserID uint64 `json:"user_id"`
        Email  string `json:"email"`
        Role   string `json:"role,omitempty"`
        jwt.RegisteredClaims
}

func NewJWTService(cfg *config.JWTConfig) *JWTService <span class="cov8" title="1">{
        return &amp;JWTService{
                accessSecret:  []byte(cfg.AccessSecret),
                accessExpiry:  cfg.AccessExpiry,
                refreshExpiry: cfg.RefreshExpiry,
                issuer:        "go-boilerplate",
                audience:      "go-boilerplate-users",
        }
}</span>

func (j *JWTService) GenerateAccessToken(ctx context.Context, userID uint64, email, role string) (string, error) <span class="cov8" title="1">{
        jti, _ := uuid.NewRandom()
        claims := &amp;Claims{
                UserID: userID,
                Email:  email,
                Role:   role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(j.accessExpiry)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        ID:        jti.String(),
                        Issuer:    j.issuer,
                        Audience:  jwt.ClaimStrings{j.audience},
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(j.accessSecret)
}</span>

func (j *JWTService) ValidateAccessToken(ctx context.Context, tokenString string) (*Claims, error) <span class="cov8" title="1">{
        return j.validateToken(tokenString, j.accessSecret)
}</span>

// GenerateStateToken generates a cryptographically secure random token
// Returns two tokens:
// 1. rawToken - the plain token for browser usage.
// 2. hashedToken - SHA256 hashed version for database storage.
// use to generate refresh_token or csrf_token
func (j *JWTService) GenerateStateToken(ctx context.Context) (string, string, error) <span class="cov8" title="1">{
        // Generate 32 random bytes (256 bits) for a secure token
        randomBytes := make([]byte, 32)
        if _, err := rand.Read(randomBytes); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>

        // Convert to hex string for the raw token (64 characters)
        <span class="cov8" title="1">rawToken := hex.EncodeToString(randomBytes)

        // Hash the token for database storage using existing HashToken method
        hashedToken := j.HashToken(rawToken)
        return rawToken, hashedToken, nil</span>
}

func (j *JWTService) validateToken(tokenString string, secret []byte) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (any, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(secret), nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, j.handleError(err)
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrCodeInvalidToken, "Authentication failed")
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(errors.ErrCodeInvalidToken, "Invalid token claims")
        }</span>

        <span class="cov8" title="1">if claims.Issuer != j.issuer </span><span class="cov8" title="1">{
                return nil, errors.New(errors.ErrCodeInvalidToken, "Invalid token issuer")
        }</span>

        <span class="cov8" title="1">validAudience := slices.Contains(claims.Audience, j.audience)
        if !validAudience </span><span class="cov8" title="1">{
                return nil, errors.New(errors.ErrCodeInvalidToken, "Invalid token audience")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

func (j *JWTService) handleError(err error) error <span class="cov8" title="1">{
        if err.Error() == "token is expired" || err.Error() == "Token is expired" </span><span class="cov0" title="0">{
                return errors.New(errors.ErrCodeExpiredToken, "Token expired")
        }</span>
        <span class="cov8" title="1">if strings.Contains(err.Error(), "signature is invalid") </span><span class="cov8" title="1">{
                return errors.New(errors.ErrCodeInvalidToken, "Invalid token signature")
        }</span>
        <span class="cov8" title="1">return errors.New(errors.ErrCodeInvalidToken, "Authentication failed")</span>
}

func (j *JWTService) GetRefreshExpiry() time.Duration <span class="cov0" title="0">{
        return j.refreshExpiry
}</span>

func (j *JWTService) GetAccessExpiry() time.Duration <span class="cov0" title="0">{
        return j.accessExpiry
}</span>

func (j *JWTService) HashToken(token string) string <span class="cov8" title="1">{
        hasher := sha256.New()
        hasher.Write([]byte(token))
        return hex.EncodeToString(hasher.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package security

import (
        "context"
        "fmt"
        "regexp"
        "strings"

        "golang.org/x/crypto/bcrypt"
)

const (
        // PolicyVersion indicates the current version of the password policy
        PolicyVersion = "v1"
)

type PasswordService struct {
        cost                 int
        minLength            int
        requireUppercase     bool
        requireLowercase     bool
        requireDigit         bool
        requireSpecialChar   bool
        maxConsecutiveChars  int
        commonPasswordsCache map[string]bool
        version              string
}

func NewPasswordService(cost int) *PasswordService <span class="cov8" title="1">{
        return &amp;PasswordService{
                cost:                cost,
                minLength:           8,
                requireUppercase:    true,
                requireLowercase:    true,
                requireDigit:        true,
                requireSpecialChar:  true,
                maxConsecutiveChars: 3,
                commonPasswordsCache: map[string]bool{
                        "password": true, "12345678": true, "qwerty": true,
                        "admin": true, "letmein": true, "welcome": true,
                },
                version: PolicyVersion,
        }
}</span>

type PasswordValidationError struct {
        Errors []string
}

func (e *PasswordValidationError) Error() string <span class="cov0" title="0">{
        return strings.Join(e.Errors, "; ")
}</span>

func (p *PasswordService) Validate(password string) error <span class="cov8" title="1">{
        var errors []string

        if len(password) &lt; p.minLength </span><span class="cov0" title="0">{
                errors = append(errors, fmt.Sprintf("password must be at least %d characters", p.minLength))
        }</span>

        <span class="cov8" title="1">if len(password) &gt; 128 </span><span class="cov0" title="0">{
                errors = append(errors, "password must not exceed 128 characters")
        }</span>

        <span class="cov8" title="1">if p.requireUppercase &amp;&amp; !regexp.MustCompile(`[A-Z]`).MatchString(password) </span><span class="cov0" title="0">{
                errors = append(errors, "password must contain at least one uppercase letter")
        }</span>

        <span class="cov8" title="1">if p.requireLowercase &amp;&amp; !regexp.MustCompile(`[a-z]`).MatchString(password) </span><span class="cov0" title="0">{
                errors = append(errors, "password must contain at least one lowercase letter")
        }</span>

        <span class="cov8" title="1">if p.requireDigit &amp;&amp; !regexp.MustCompile(`[0-9]`).MatchString(password) </span><span class="cov0" title="0">{
                errors = append(errors, "password must contain at least one digit")
        }</span>

        <span class="cov8" title="1">if p.requireSpecialChar &amp;&amp; !regexp.MustCompile(`[!@#$%^&amp;*()_+\-=\[\]{};':"\\|,.&lt;&gt;\/?]`).MatchString(password) </span><span class="cov0" title="0">{
                errors = append(errors, "password must contain at least one special character")
        }</span>

        <span class="cov8" title="1">if p.hasConsecutiveChars(password, p.maxConsecutiveChars) </span><span class="cov0" title="0">{
                errors = append(errors, fmt.Sprintf("password must not contain more than %d consecutive identical characters", p.maxConsecutiveChars))
        }</span>

        <span class="cov8" title="1">lowerPassword := strings.ToLower(password)
        if p.commonPasswordsCache[lowerPassword] </span><span class="cov0" title="0">{
                errors = append(errors, "password is too common")
        }</span>

        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;PasswordValidationError{Errors: errors}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (p *PasswordService) hasConsecutiveChars(password string, max int) bool <span class="cov8" title="1">{
        if len(password) &lt; max </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">count := 1
        for i := 1; i &lt; len(password); i++ </span><span class="cov8" title="1">{
                if password[i] == password[i-1] </span><span class="cov8" title="1">{
                        count++
                        if count &gt;= max </span><span class="cov0" title="0">{
                                return true
                        }</span>
                } else<span class="cov8" title="1"> {
                        count = 1
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (p *PasswordService) Hash(ctx context.Context, password string) (string, error) <span class="cov8" title="1">{
        if err := p.Validate(password); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">hash, err := bcrypt.GenerateFromPassword([]byte(password), p.cost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to hash password: %w", err)
        }</span>
        <span class="cov8" title="1">return string(hash), nil</span>
}

func (p *PasswordService) Compare(ctx context.Context, hashedPassword, password string) error <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package security

import (
        "context"
        "errors"
        "fmt"
        "hash/fnv"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/redis/go-redis/v9"
)

// RateLimiter defines the interface for rate limiting strategies
type RateLimiter interface {
        Allow(ctx context.Context, identifier string, limit int, window time.Duration) (bool, error)
        Reset(ctx context.Context, identifier string) error
        GetRemaining(ctx context.Context, identifier string, limit int, window time.Duration) (int, error)
}

// Configuration for sharded in-memory limiter
const (
        // Total max clients across all shards to prevent OOM
        MaxTrackedClients = 100000
        // ShardCount determines the granularity of locking (Power of 2 is preferred)
        ShardCount = 32
        // Per-shard limit
        MaxTrackedClientsPerShard = MaxTrackedClients / ShardCount
)

// bucketInfo holds the rate limit state for a single client using Fixed Window
type bucketInfo struct {
        count   int
        resetAt time.Time
}

// rateLimitShard represents a slice of the rate limiter with its own lock
type rateLimitShard struct {
        mu       sync.RWMutex
        requests map[string]*bucketInfo
}

// InMemoryRateLimiter implements a thread-safe, sharded fixed-window limiter
type InMemoryRateLimiter struct {
        shards []*rateLimitShard
        stopCh chan struct{}
}

// NewInMemoryRateLimiter initializes the sharded limiter and starts the cleanup routine
func NewInMemoryRateLimiter() *InMemoryRateLimiter <span class="cov8" title="1">{
        rl := &amp;InMemoryRateLimiter{
                shards: make([]*rateLimitShard, ShardCount),
                stopCh: make(chan struct{}),
        }

        // Initialize shards
        for i := 0; i &lt; ShardCount; i++ </span><span class="cov8" title="1">{
                rl.shards[i] = &amp;rateLimitShard{
                        requests: make(map[string]*bucketInfo),
                }
        }</span>

        <span class="cov8" title="1">go rl.cleanup()
        return rl</span>
}

// getShard maps an identifier to a specific shard index using FNV hashing
func (rl *InMemoryRateLimiter) getShard(identifier string) *rateLimitShard <span class="cov8" title="1">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(identifier))
        idx := h.Sum32() % uint32(ShardCount)
        return rl.shards[idx]
}</span>

// cleanup runs in the background to remove expired entries
func (rl *InMemoryRateLimiter) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        now := time.Now()
                        for _, shard := range rl.shards </span><span class="cov0" title="0">{
                                // Lock only this shard for cleanup
                                shard.mu.Lock()
                                for key, bucket := range shard.requests </span><span class="cov0" title="0">{
                                        if now.After(bucket.resetAt) </span><span class="cov0" title="0">{
                                                delete(shard.requests, key)
                                        }</span>
                                }
                                <span class="cov0" title="0">shard.mu.Unlock()</span>
                        }
                case &lt;-rl.stopCh:<span class="cov0" title="0">
                        return</span> // Graceful shutdown
                }
        }
}

// Allow checks if the request is allowed within the rate limit
func (rl *InMemoryRateLimiter) Allow(ctx context.Context, identifier string, limit int, window time.Duration) (bool, error) <span class="cov8" title="1">{
        shard := rl.getShard(identifier)

        shard.mu.Lock()
        defer shard.mu.Unlock()

        now := time.Now()
        bucket, exists := shard.requests[identifier]

        // Handle new clients
        if !exists </span><span class="cov8" title="1">{
                // Enforce memory bounds per shard
                if len(shard.requests) &gt;= MaxTrackedClientsPerShard </span><span class="cov8" title="1">{
                        // Prune expired entries in this shard immediately
                        rl.pruneShard(shard, now)

                        // If still full, fail closed to protect memory
                        if len(shard.requests) &gt;= MaxTrackedClientsPerShard </span><span class="cov8" title="1">{
                                return false, errors.New("rate limit capacity exceeded")
                        }</span>
                }

                <span class="cov8" title="1">bucket = &amp;bucketInfo{
                        count:   0,
                        resetAt: now.Add(window),
                }
                shard.requests[identifier] = bucket</span>
        }

        // Fixed Window Logic: Reset if the window has expired
        <span class="cov8" title="1">if now.After(bucket.resetAt) </span><span class="cov0" title="0">{
                bucket.count = 0
                bucket.resetAt = now.Add(window)
        }</span>

        <span class="cov8" title="1">if bucket.count &gt;= limit </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">bucket.count++
        return true, nil</span>
}

// pruneShard removes expired entries from a specific shard
// Caller must hold the shard lock
func (rl *InMemoryRateLimiter) pruneShard(shard *rateLimitShard, now time.Time) <span class="cov8" title="1">{
        for key, bucket := range shard.requests </span><span class="cov8" title="1">{
                if now.After(bucket.resetAt) </span><span class="cov8" title="1">{
                        delete(shard.requests, key)
                }</span>
        }
}

// Reset clears the rate limit for a specific identifier
func (rl *InMemoryRateLimiter) Reset(ctx context.Context, identifier string) error <span class="cov0" title="0">{
        shard := rl.getShard(identifier)

        shard.mu.Lock()
        defer shard.mu.Unlock()

        delete(shard.requests, identifier)
        return nil
}</span>

// GetRemaining calculates remaining requests for an identifier
func (rl *InMemoryRateLimiter) GetRemaining(ctx context.Context, identifier string, limit int, window time.Duration) (int, error) <span class="cov0" title="0">{
        shard := rl.getShard(identifier)

        shard.mu.RLock()
        defer shard.mu.RUnlock()

        bucket, exists := shard.requests[identifier]
        if !exists </span><span class="cov0" title="0">{
                return limit, nil
        }</span>

        <span class="cov0" title="0">now := time.Now()

        // If window expired, full limit is available
        if now.After(bucket.resetAt) </span><span class="cov0" title="0">{
                return limit, nil
        }</span>

        <span class="cov0" title="0">remaining := limit - bucket.count
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">return remaining, nil</span>
}

// RedisRateLimiter implementation (Unchanged)
type RedisRateLimiter struct {
        client *redis.Client
        prefix string
}

func NewRedisRateLimiter(client *redis.Client) *RedisRateLimiter <span class="cov8" title="1">{
        return &amp;RedisRateLimiter{
                client: client,
                prefix: "rl:",
        }
}</span>

func (rl *RedisRateLimiter) Allow(ctx context.Context, identifier string, limit int, window time.Duration) (bool, error) <span class="cov8" title="1">{
        key := fmt.Sprintf("%s%s", rl.prefix, identifier)

        pipe := rl.client.Pipeline()
        incr := pipe.Incr(ctx, key)
        pipe.Expire(ctx, key, window)

        if _, err := pipe.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("redis pipeline failed: %w", err)
        }</span>

        <span class="cov8" title="1">count, err := incr.Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("redis incr failed: %w", err)
        }</span>

        <span class="cov8" title="1">return count &lt;= int64(limit), nil</span>
}

func (rl *RedisRateLimiter) Reset(ctx context.Context, identifier string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("%s%s", rl.prefix, identifier)
        return rl.client.Del(ctx, key).Err()
}</span>

func (rl *RedisRateLimiter) GetRemaining(ctx context.Context, identifier string, limit int, window time.Duration) (int, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("%s%s", rl.prefix, identifier)

        count, err := rl.client.Get(ctx, key).Int()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return limit, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("redis get failed: %w", err)
        }</span>

        <span class="cov0" title="0">remaining := limit - count
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>
        <span class="cov0" title="0">return remaining, nil</span>
}

// RouteRateLimitMiddleware applies rate limiting to a gin route
func RouteRateLimitMiddleware(rl RateLimiter, limit int, window time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                identifier := c.ClientIP()

                allowed, err := rl.Allow(c.Request.Context(), identifier, limit, window)
                if err != nil </span><span class="cov0" title="0">{
                        // Fail open on internal error to allow traffic, or log error
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">remaining, _ := rl.GetRemaining(c.Request.Context(), identifier, limit, window)

                c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", limit))
                c.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining))
                c.Header("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(window).Unix()))

                if !allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", fmt.Sprintf("%d", int(window.Seconds())))
                        c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                                "success": false,
                                "error": gin.H{
                                        "code":    "TOO_MANY_REQUESTS",
                                        "message": "Rate limit exceeded. Please try again later.",
                                },
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func (rl *InMemoryRateLimiter) Stop() <span class="cov0" title="0">{
        close(rl.stopCh)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package security

import "context"

type contextKey string

const (
        UserIDKey    contextKey = "user_id"
        UserRoleKey  contextKey = "user_role"
        UserEmailKey contextKey = "user_email"
)

// ContextWithUserID adds the user ID to the context
func ContextWithUserID(ctx context.Context, userID uint64) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, UserIDKey, userID)
}</span>

// ContextWithUserRole adds the user role to the context
func ContextWithUserRole(ctx context.Context, role string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, UserRoleKey, role)
}</span>

// ContextWithUserEmail adds the user email to the context
func ContextWithUserEmail(ctx context.Context, email string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, UserEmailKey, email)
}</span>

// UserIDFromContext retrieves the user ID from context
func UserIDFromContext(ctx context.Context) (uint64, bool) <span class="cov0" title="0">{
        userID, ok := ctx.Value(UserIDKey).(uint64)
        return userID, ok
}</span>

// UserRoleFromContext retrieves the user role from context
func UserRoleFromContext(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        role, ok := ctx.Value(UserRoleKey).(string)
        return role, ok
}</span>

// UserEmailFromContext retrieves the user email from context
func UserEmailFromContext(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        email, ok := ctx.Value(UserEmailKey).(string)
        return email, ok
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package attendance

import "github.com/waqasmani/go-boilerplate/internal/shared/errors"

// Domain-specific attendance errors
var (
        // Check-in/out errors
        ErrOpenSessionExists = errors.New(errors.ErrCodeConflict, "An open attendance session already exists. Please check out first")
        ErrNoOpenSession     = errors.New(errors.ErrCodeBadRequest, "No open attendance session found")
        ErrSessionNotFound   = errors.New(errors.ErrCodeNotFound, "Attendance session not found")
        ErrAlreadyCheckedOut = errors.New(errors.ErrCodeBadRequest, "This session has already been checked out")

        // Time validation errors
        ErrTimeSkewTooLarge = errors.New(errors.ErrCodeBadRequest, "Client timestamp differs from server time by more than allowed tolerance")
        ErrCheckOutBeforeIn = errors.New(errors.ErrCodeBadRequest, "Check-out time cannot be before check-in time")
        ErrInvalidDateRange = errors.New(errors.ErrCodeValidation, "Invalid date range: end date must be after start date")
        ErrFutureDate       = errors.New(errors.ErrCodeBadRequest, "Cannot check in/out with future timestamps")

        // Geofence errors
        ErrGeofenceViolation = errors.New(errors.ErrCodeForbidden, "Location outside allowed geofence area")
        ErrLocationRequired  = errors.New(errors.ErrCodeBadRequest, "Location coordinates are required when geofence is enabled")

        // Shift errors
        ErrShiftNotFound    = errors.New(errors.ErrCodeNotFound, "Shift not found")
        ErrNoShiftAssigned  = errors.New(errors.ErrCodeNotFound, "No shift assigned for this date")
        ErrShiftOverlap     = errors.New(errors.ErrCodeConflict, "Shift assignment overlaps with existing assignment")
        ErrInvalidShiftTime = errors.New(errors.ErrCodeValidation, "Invalid shift time: end time must be after start time")

        // Time off errors
        ErrTimeOffNotFound          = errors.New(errors.ErrCodeNotFound, "Time off request not found")
        ErrTimeOffAlreadyReviewed   = errors.New(errors.ErrCodeConflict, "Time off request has already been reviewed")
        ErrInsufficientLeaveBalance = errors.New(errors.ErrCodeBadRequest, "Insufficient leave balance for this request")
        ErrTimeOffOverlap           = errors.New(errors.ErrCodeConflict, "Time off request overlaps with existing approved leave")

        // Authorization errors
        ErrUnauthorizedShiftEdit   = errors.New(errors.ErrCodeForbidden, "Only managers can modify shift assignments")
        ErrUnauthorizedApproval    = errors.New(errors.ErrCodeForbidden, "Only managers can approve time off requests")
        ErrCannotApproveOwnRequest = errors.New(errors.ErrCodeForbidden, "Cannot approve your own time off request")

        // Holiday errors
        ErrHolidayNotFound = errors.New(errors.ErrCodeNotFound, "Holiday not found")
        ErrHolidayExists   = errors.New(errors.ErrCodeConflict, "A holiday already exists for this date")

        // Report errors
        ErrInvalidReportPeriod = errors.New(errors.ErrCodeBadRequest, "Invalid report period: must not exceed 90 days")
        ErrNoDataForPeriod     = errors.New(errors.ErrCodeNotFound, "No attendance data found for specified period")
)

// WrapAttendanceError wraps a generic error with context
func WrapAttendanceError(err error, message string) *errors.AppError <span class="cov8" title="1">{
        return errors.Wrap(err, errors.ErrCodeInternal, message)
}</span>

// ValidationError creates a validation error with details
func ValidationError(field, message string) *errors.AppError <span class="cov8" title="1">{
        return errors.WithDetails(
                errors.ErrCodeValidation,
                "Validation failed",
                map[string]string{field: message},
        )
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package attendance

import (
        "database/sql"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/sqlc"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
        "github.com/waqasmani/go-boilerplate/internal/shared/utils"
        "github.com/waqasmani/go-boilerplate/internal/shared/validator"
)

// Handler handles HTTP requests for attendance
type Handler struct {
        service *Service
}

// NewHandler creates a new attendance handler
func NewHandler(service *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{service: service}
}</span>

// CheckIn godoc
// @Summary Check in to work
// @Description Records employee check-in with optional geolocation
// @Tags Attendance
// @Accept json
// @Produce json
// @Param body body CheckInRequest true "Check-in details"
// @Success 201 {object} utils.Response{data=AttendanceResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 409 {object} utils.Response
// @Security     Bearer
// @Router /attendance/check-in [post]
func (h *Handler) CheckIn(c *gin.Context) <span class="cov8" title="1">{
        userID, err := middleware.GetCurrentUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req CheckInRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        // Add this validation block
        <span class="cov8" title="1">if err := h.service.validator.Validate(req); err != nil </span><span class="cov8" title="1">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov0" title="0">attendance, err := h.service.CheckIn(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov0" title="0">utils.Success(c, http.StatusCreated, attendance)</span>
}

// CheckOut godoc
// @Summary Check out from work
// @Description Records employee check-out and calculates duration
// @Tags Attendance
// @Accept json
// @Produce json
// @Param body body CheckOutRequest true "Check-out details"
// @Success 200 {object} utils.Response{data=AttendanceResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /attendance/check-out [post]
func (h *Handler) CheckOut(c *gin.Context) <span class="cov8" title="1">{
        userID, err := middleware.GetCurrentUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req CheckOutRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        // Add this validation block
        <span class="cov8" title="1">if err := h.service.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov8" title="1">attendance, err := h.service.CheckOut(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">utils.Success(c, http.StatusOK, attendance)</span>
}

// ListAttendance godoc
// @Summary List attendance records
// @Description Retrieves attendance records with pagination and filters
// @Tags Attendance
// @Accept json
// @Produce json
// @Param user_id query int false "User ID filter"
// @Param from query string false "Start date (RFC3339)"
// @Param to query string false "End date (RFC3339)"
// @Param status query string false "Status filter" Enums(present, on_leave, absent, manual)
// @Param shift_id query int false "Shift ID filter"
// @Param limit query int false "Page size" default(20) minimum(1) maximum(100)
// @Param page query int false "Page number" default(1) minimum(1)
// @Success 200 {object} utils.Response{data=ListAttendanceResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Security     Bearer
// @Router /attendance [get]
func (h *Handler) ListAttendance(c *gin.Context) <span class="cov8" title="1">{
        var req ListAttendanceRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid query parameters"))
                return
        }</span>

        <span class="cov8" title="1">if err := h.service.validator.Validate(req); err != nil </span><span class="cov8" title="1">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov8" title="1">result, err := h.service.ListAttendance(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">utils.Success(c, http.StatusOK, result)</span>
}

// GetAttendance godoc
// @Summary Get attendance by ID
// @Description Retrieves a single attendance record by ID
// @Tags Attendance
// @Accept json
// @Produce json
// @Param id path int true "Attendance ID"
// @Success 200 {object} utils.Response{data=AttendanceResponse}
// @Failure 401 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /attendance/{id} [get]
func (h *Handler) GetAttendance(c *gin.Context) <span class="cov8" title="1">{
        attendanceID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid attendance ID"))
                return
        }</span>

        <span class="cov8" title="1">attendance, err := h.service.queries.GetAttendanceByID(c.Request.Context(), attendanceID)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, ErrSessionNotFound)
                return
        }</span>

        // Authorization: user can only view own records unless admin/manager
        <span class="cov8" title="1">userID, _ := middleware.GetCurrentUserID(c)
        if attendance.UserID != userID &amp;&amp; !middleware.IsAdmin(c) </span><span class="cov8" title="1">{
                utils.Error(c, errors.ErrForbidden)
                return
        }</span>

        <span class="cov8" title="1">utils.Success(c, http.StatusOK, h.service.toAttendanceResponse(attendance))</span>
}

// ManualAttendance godoc
// @Summary Manually edit attendance (Admin/Manager only)
// @Description Allows managers to manually create or edit attendance records
// @Tags Attendance
// @Accept json
// @Produce json
// @Param id path int true "Attendance ID (0 for new)"
// @Param body body ManualAttendanceRequest true "Manual attendance data"
// @Success 200 {object} utils.Response{data=AttendanceResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Security     Bearer
// @Router /attendance/{id}/manual [put]
func (h *Handler) ManualAttendance(c *gin.Context) <span class="cov8" title="1">{
        attendanceID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid attendance ID"))
                return
        }</span>

        <span class="cov8" title="1">var req ManualAttendanceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov8" title="1">if err := h.service.validator.Validate(req); err != nil </span><span class="cov8" title="1">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov8" title="1">duration := uint32(req.CheckOutAt.Sub(req.CheckInAt).Seconds())
        overtime := uint32(0)
        if req.OvertimeSeconds != nil </span><span class="cov0" title="0">{
                overtime = *req.OvertimeSeconds
        }</span>

        <span class="cov8" title="1">err = h.service.queries.UpdateAttendanceManual(c.Request.Context(), sqlc.UpdateAttendanceManualParams{
                ID:              attendanceID,
                CheckInAt:       req.CheckInAt,
                CheckOutAt:      sql.NullTime{Valid: true, Time: req.CheckOutAt},
                DurationSeconds: sql.NullInt32{Valid: true, Int32: int32(duration)},
                OvertimeSeconds: sql.NullInt32{Valid: true, Int32: int32(overtime)},
        })
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, WrapAttendanceError(err, "Failed to update attendance"))
                return
        }</span>

        // Add audit note
        <span class="cov8" title="1">managerID, _ := middleware.GetCurrentUserID(c)
        _ = h.service.queries.CreateAttendanceNote(c.Request.Context(), sqlc.CreateAttendanceNoteParams{
                AttendanceID: attendanceID,
                AddedBy:      managerID,
                Note:         fmt.Sprintf("Manual edit: %s", req.Reason),
        })

        // Audit log
        h.service.auditLogger.LogSecurityEvent(c.Request.Context(), observability.SecurityEvent{
                Type:     "attendance",
                Action:   "manual_edit",
                UserID:   managerID,
                Resource: fmt.Sprintf("attendance:%d", attendanceID),
                Success:  true,
        })

        updated, _ := h.service.queries.GetAttendanceByID(c.Request.Context(), attendanceID)
        utils.Success(c, http.StatusOK, h.service.toAttendanceResponse(updated))</span>
}

// GetLeaveBalance godoc
// @Summary Get leave balance
// @Description Retrieves current leave balance for authenticated user
// @Tags Attendance
// @Accept json
// @Produce json
// @Param leave_type query string false "Leave type" Enums(sick, vacation, personal)
// @Success 200 {object} utils.Response{data=[]LeaveBalanceResponse}
// @Failure 401 {object} utils.Response
// @Security     Bearer
// @Router /attendance/leave-balance [get]
func (h *Handler) GetLeaveBalance(c *gin.Context) <span class="cov8" title="1">{
        userID, err := middleware.GetCurrentUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">leaveType := c.Query("leave_type")
        leaveTypes := []string{"sick", "vacation", "personal"}
        var balances []LeaveBalanceResponse

        if leaveType != "" </span><span class="cov8" title="1">{
                balance, err := h.service.GetLeaveBalance(c.Request.Context(), userID, leaveType)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(c, err)
                        return
                }</span>
                <span class="cov8" title="1">balances = append(balances, *balance)</span>
        } else<span class="cov8" title="1"> {
                // Return all types
                for _, lt := range leaveTypes </span><span class="cov8" title="1">{
                        balance, err := h.service.GetLeaveBalance(c.Request.Context(), userID, lt)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">balances = append(balances, *balance)</span>
                }
        }

        <span class="cov8" title="1">utils.Success(c, http.StatusOK, balances)</span>
}

// RequestTimeOff godoc
// @Summary Request time off
// @Description Employee submits a time off request
// @Tags Time Off
// @Accept json
// @Produce json
// @Param body body TimeOffRequest true "Time off request"
// @Success 201 {object} utils.Response{data=TimeOffResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Security     Bearer
// @Router /attendance/time-off [post]
func (h *Handler) RequestTimeOff(c *gin.Context) <span class="cov8" title="1">{
        userID, err := middleware.GetCurrentUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">var req TimeOffRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov8" title="1">if err := h.service.validator.Validate(req); err != nil </span><span class="cov8" title="1">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov8" title="1">startDate, _ := time.Parse("2006-01-02", req.StartDate)
        endDate, _ := time.Parse("2006-01-02", req.EndDate)
        daysCount := calculateBusinessDays(startDate, endDate)

        result, err := h.service.queries.CreateTimeOffRequest(c.Request.Context(), sqlc.CreateTimeOffRequestParams{
                UserID:    userID,
                LeaveType: req.LeaveType,
                StartDate: startDate,
                EndDate:   endDate,
                DaysCount: fmt.Sprintf("%.2f", daysCount),
                Reason:    sql.NullString{Valid: true, String: req.Reason},
                Status:    "pending",
        })
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, WrapAttendanceError(err, "Failed to create time off request"))
                return
        }</span>

        <span class="cov8" title="1">timeOffID, _ := result.LastInsertId()
        utils.Success(c, http.StatusCreated, gin.H{"id": timeOffID, "status": "pending"})</span>
}

// ApproveTimeOff godoc
// @Summary Approve time off (Manager only)
// @Description Manager approves a pending time off request
// @Tags Time Off
// @Accept json
// @Produce json
// @Param id path int true "Time off request ID"
// @Param body body ReviewTimeOffRequest true "Review note"
// @Success 200 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /attendance/time-off/{id}/approve [patch]
func (h *Handler) ApproveTimeOff(c *gin.Context) <span class="cov8" title="1">{
        timeOffID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid time off ID"))
                return
        }</span>

        <span class="cov8" title="1">managerID, _ := middleware.GetCurrentUserID(c)

        var req ReviewTimeOffRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov8" title="1">err = h.service.ApproveTimeOff(c.Request.Context(), timeOffID, managerID, req.ReviewNote)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, WrapAttendanceError(err, "Failed to approve time off"))
                return
        }</span>

        <span class="cov8" title="1">h.service.auditLogger.LogSecurityEvent(c.Request.Context(), observability.SecurityEvent{
                Type:     "time_off",
                Action:   "approve",
                UserID:   managerID,
                Resource: fmt.Sprintf("time_off:%d", timeOffID),
                Success:  true,
        })

        utils.Success(c, http.StatusOK, gin.H{"message": "Time off approved"})</span>
}

// RejectTimeOff godoc
// @Summary Reject time off (Manager only)
// @Description Manager rejects a pending time off request
// @Tags Time Off
// @Accept json
// @Produce json
// @Param id path int true "Time off request ID"
// @Param body body ReviewTimeOffRequest true "Review note"
// @Success 200 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /attendance/time-off/{id}/reject [patch]
func (h *Handler) RejectTimeOff(c *gin.Context) <span class="cov8" title="1">{
        timeOffID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid time off ID"))
                return
        }</span>

        <span class="cov8" title="1">managerID, _ := middleware.GetCurrentUserID(c)

        var req ReviewTimeOffRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov8" title="1">err = h.service.RejectTimeOff(c.Request.Context(), timeOffID, managerID, req.ReviewNote)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, WrapAttendanceError(err, "Failed to reject time off"))
                return
        }</span>

        <span class="cov8" title="1">h.service.auditLogger.LogSecurityEvent(c.Request.Context(), observability.SecurityEvent{
                Type:     "time_off",
                Action:   "reject",
                UserID:   managerID,
                Resource: fmt.Sprintf("time_off:%d", timeOffID),
                Success:  true,
        })

        utils.Success(c, http.StatusOK, gin.H{"message": "Time off rejected"})</span>
}

// DailySummary godoc
// @Summary Get daily attendance summary
// @Description Retrieves attendance summary for a specific date
// @Tags Reports
// @Accept json
// @Produce json
// @Param date query string true "Date (YYYY-MM-DD format)"
// @Success 200 {object} utils.Response{data=DailySummaryResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /reports/daily-summary [get]
func (h *Handler) DailySummary(c *gin.Context) <span class="cov8" title="1">{
        dateStr := c.Query("date")
        if dateStr == "" </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Date parameter is required"))
                return
        }</span>

        <span class="cov8" title="1">date, err := time.Parse("2006-01-02", dateStr)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid date format. Use YYYY-MM-DD format"))
                return
        }</span>

        <span class="cov8" title="1">summary, err := h.service.DailySummary(c.Request.Context(), date)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">utils.Success(c, http.StatusOK, summary)</span>
}

// ExportEmployee godoc
// @Summary Export employee timesheet
// @Description Exports timesheet data for an employee for a specific period
// @Tags Reports
// @Accept json
// @Param id path int true "Employee ID"
// @Param start_date query string true "Start date (YYYY-MM-DD format)"
// @Param end_date query string true "End date (YYYY-MM-DD format)"
// @Success 200 {file} file "Timesheet CSV file"
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /reports/employee/{id}/export [get]
func (h *Handler) ExportEmployee(c *gin.Context) <span class="cov8" title="1">{
        employeeID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid employee ID"))
                return
        }</span>

        <span class="cov8" title="1">startDateStr := c.Query("start_date")
        endDateStr := c.Query("end_date")

        if startDateStr == "" || endDateStr == "" </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Start date and end date parameters are required"))
                return
        }</span>

        <span class="cov8" title="1">startDate, err := time.Parse("2006-01-02", startDateStr)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid start date format. Use YYYY-MM-DD format"))
                return
        }</span>

        <span class="cov8" title="1">endDate, err := time.Parse("2006-01-02", endDateStr)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid end date format. Use YYYY-MM-DD format"))
                return
        }</span>

        <span class="cov8" title="1">if endDate.Before(startDate) </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "End date must be after start date"))
                return
        }</span>

        // Add one day to end date to include the entire last day
        <span class="cov8" title="1">endDate = endDate.AddDate(0, 0, 1)

        // Authorization: user can only export their own data unless admin/manager
        userID, _ := middleware.GetCurrentUserID(c)
        if employeeID != userID &amp;&amp; !middleware.IsAdmin(c) </span><span class="cov0" title="0">{
                utils.Error(c, errors.ErrForbidden)
                return
        }</span>

        <span class="cov8" title="1">timesheet, err := h.service.ExportTimesheetForPeriod(c.Request.Context(), employeeID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        // Set headers for CSV download
        <span class="cov8" title="1">c.Header("Content-Type", "text/csv")
        c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=timesheet_%s_%s.csv", startDateStr, endDateStr))

        // Write CSV header
        c.String(http.StatusOK, "Date,Employee,CheckIn,CheckOut,DurationHours,OvertimeHours,Status,Shift\n")

        // Write CSV rows
        for _, record := range timesheet </span><span class="cov8" title="1">{
                durationHours := 0.0
                if record.DurationSeconds.Valid </span><span class="cov8" title="1">{
                        durationHours = float64(record.DurationSeconds.Int32) / 3600.0
                }</span>

                <span class="cov8" title="1">overtimeHours := 0.0
                if record.OvertimeSeconds.Valid </span><span class="cov8" title="1">{
                        overtimeHours = float64(record.OvertimeSeconds.Int32) / 3600.0
                }</span>

                <span class="cov8" title="1">checkInStr := ""
                if !record.CheckInAt.IsZero() </span><span class="cov8" title="1">{
                        checkInStr = record.CheckInAt.Format("2006-01-02 15:04:05")
                }</span>

                <span class="cov8" title="1">checkOutStr := ""
                if record.CheckOutAt.Valid </span><span class="cov8" title="1">{
                        checkOutStr = record.CheckOutAt.Time.Format("2006-01-02 15:04:05")
                }</span>

                <span class="cov8" title="1">shiftName := ""
                if record.ShiftName.Valid </span><span class="cov0" title="0">{
                        shiftName = record.ShiftName.String
                }</span>

                <span class="cov8" title="1">row := fmt.Sprintf("%s,%s %s,%s,%s,%.2f,%.2f,%s,%s\n",
                        record.WorkDate.Format("2006-01-02"),
                        record.FirstName,
                        record.LastName,
                        checkInStr,
                        checkOutStr,
                        durationHours,
                        overtimeHours,
                        record.Status,
                        shiftName,
                )
                c.Writer.WriteString(row)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package attendance

import (
        "github.com/gin-gonic/gin"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware"
)

func RegisterRoutes(router *gin.Engine, handler *Handler, authMiddleware *middleware.AuthMiddleware) <span class="cov8" title="1">{
        // Employee routes (authenticated)
        attendanceGroup := router.Group("/api/v1/attendance")
        attendanceGroup.Use(authMiddleware.Authenticate())
        </span><span class="cov8" title="1">{
                attendanceGroup.POST("/check-in", handler.CheckIn)
                attendanceGroup.POST("/check-out", handler.CheckOut)
                attendanceGroup.GET("", handler.ListAttendance)
                attendanceGroup.GET("/:id", handler.GetAttendance)
                attendanceGroup.GET("/leave-balance", handler.GetLeaveBalance)
                attendanceGroup.POST("/time-off", handler.RequestTimeOff)
        }</span>

        // Manager routes
        <span class="cov8" title="1">managerGroup := attendanceGroup.Group("")
        managerGroup.Use(authMiddleware.Authorize("manager", "admin"))
        </span><span class="cov8" title="1">{
                managerGroup.PUT("/:id/manual", handler.ManualAttendance)
                managerGroup.PATCH("/time-off/:id/approve", handler.ApproveTimeOff)
                managerGroup.PATCH("/time-off/:id/reject", handler.RejectTimeOff)
        }</span>

        // Reports (manager/admin)
        <span class="cov8" title="1">reportsGroup := router.Group("/api/v1/reports")
        reportsGroup.Use(authMiddleware.Authenticate(), authMiddleware.Authorize("manager", "admin"))
        </span><span class="cov8" title="1">{
                reportsGroup.GET("/daily-summary", handler.DailySummary)
                reportsGroup.GET("/employee/:id/export", handler.ExportEmployee)
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package attendance

import (
        "context"
        "time"

        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
)

// Scheduler handles background jobs
type Scheduler struct {
        service *Service
        logger  *observability.Logger
}

func NewScheduler(service *Service, logger *observability.Logger) *Scheduler <span class="cov8" title="1">{
        return &amp;Scheduler{service: service, logger: logger}
}</span>

// StartAutoCheckoutJob runs nightly to close stale sessions
func (s *Scheduler) StartAutoCheckoutJob(ctx context.Context, interval time.Duration) <span class="cov8" title="1">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        count, err := s.service.AutoCheckoutStaleSessions(ctx, 24)
                        if err != nil </span><span class="cov8" title="1">{
                                s.logger.Error(ctx, "Auto-checkout job failed", s.logger.Field("error", err))
                        }</span> else<span class="cov8" title="1"> {
                                s.logger.Info(ctx, "Auto-checkout completed", s.logger.Field("count", count))
                        }</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

// StartAccrualJob runs monthly to credit leave days
func (s *Scheduler) StartAccrualJob(ctx context.Context) <span class="cov8" title="1">{
        ticker := time.NewTicker(24 * time.Hour)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        now := time.Now()
                        if now.Day() == 1 </span><span class="cov0" title="0">{ // First day of month
                                // TODO: Implement accrual logic
                                s.logger.Info(ctx, "Monthly accrual job executed")
                        }</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package attendance

import (
        "context"
        "database/sql"
        "fmt"
        "math"
        "time"

        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/sqlc"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
        "github.com/waqasmani/go-boilerplate/internal/shared/validator"
)

// Service handles attendance business logic
type Service struct {
        queries     *sqlc.Queries
        auditLogger *observability.AuditLogger
        validator   *validator.Validator
        logger      *observability.Logger
        cfg         *config.Config
}

// NewService creates a new attendance service
func NewService(
        queries *sqlc.Queries,
        auditLogger *observability.AuditLogger,
        validator *validator.Validator,
        logger *observability.Logger,
        cfg *config.Config,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                queries:     queries,
                auditLogger: auditLogger,
                validator:   validator,
                logger:      logger,
                cfg:         cfg,
        }
}</span>

// CheckIn creates a new attendance record
func (s *Service) CheckIn(ctx context.Context, userID uint64, req CheckInRequest) (*AttendanceResponse, error) <span class="cov8" title="1">{
        now := time.Now().UTC()

        // Validate client timestamp skew if provided
        if req.ClientTimestamp != nil </span><span class="cov8" title="1">{
                skew := now.Sub(*req.ClientTimestamp).Abs()
                if skew &gt; 5*time.Minute </span><span class="cov8" title="1">{
                        return nil, ErrTimeSkewTooLarge
                }</span>
        }
        <span class="cov8" title="1">lockKey := fmt.Sprintf("checkin_lock_%d", userID)

        // Acquire distributed lock
        if err := s.queries.AcquireLock(ctx, lockKey); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, errors.ErrCodeInternal, "Failed to acquire lock")
        }</span>
        <span class="cov8" title="1">defer s.queries.ReleaseLock(ctx, lockKey)
        // Check for existing open session (if multi-session disabled)
        openSession, err := s.queries.GetOpenAttendanceForUser(ctx, userID)
        if err == nil &amp;&amp; openSession.ID &gt; 0 </span><span class="cov8" title="1">{
                // Multi-session disabled by default
                return nil, ErrOpenSessionExists
        }</span>

        <span class="cov8" title="1">if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to check existing sessions")
        }</span>

        // Get shift for today
        <span class="cov8" title="1">shiftAssignment, err := s.queries.GetEmployeeShiftForDate(ctx, sqlc.GetEmployeeShiftForDateParams{
                UserID:        userID,
                EffectiveDate: now,
                EndDate:       sql.NullTime{Valid: true, Time: now},
        })
        var shiftID *uint64
        isLate := false
        if err == nil </span><span class="cov8" title="1">{
                shiftID = &amp;shiftAssignment.ShiftID
                // Check if late: compare with shift start time
                shiftStart, _ := time.Parse("15:04:05", shiftAssignment.StartTime.Format("15:04:05"))
                todayShiftStart := time.Date(now.Year(), now.Month(), now.Day(), shiftStart.Hour(), shiftStart.Minute(), 0, 0, time.UTC)
                if now.After(todayShiftStart.Add(5 * time.Minute)) </span><span class="cov0" title="0">{ // 5 min grace period
                        isLate = true
                }</span>
        }

        <span class="cov8" title="1">var shiftIDParam sql.NullInt64
        if shiftID != nil </span><span class="cov8" title="1">{
                shiftIDParam = sql.NullInt64{Valid: true, Int64: int64(*shiftID)}
        }</span>

        // Safely handle optional fields to avoid nil pointer dereference
        <span class="cov8" title="1">var checkInLat, checkInLng sql.NullString
        if req.Latitude != nil </span><span class="cov8" title="1">{
                checkInLat = sql.NullString{Valid: true, String: fmt.Sprintf("%f", *req.Latitude)}
        }</span>
        <span class="cov8" title="1">if req.Longitude != nil </span><span class="cov8" title="1">{
                checkInLng = sql.NullString{Valid: true, String: fmt.Sprintf("%f", *req.Longitude)}
        }</span>

        <span class="cov8" title="1">var clientCheckInAt sql.NullTime
        if req.ClientTimestamp != nil </span><span class="cov8" title="1">{
                clientCheckInAt = sql.NullTime{Valid: true, Time: *req.ClientTimestamp}
        }</span>

        <span class="cov8" title="1">result, err := s.queries.CreateAttendance(ctx, sqlc.CreateAttendanceParams{
                UserID:          userID,
                ShiftID:         shiftIDParam,
                CheckInAt:       now,
                CheckInLat:      checkInLat,
                CheckInLng:      checkInLng,
                ClientCheckInAt: clientCheckInAt,
                IsLate:          isLate,
                Status:          sqlc.AttendanceRecordsStatusPresent,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to create attendance record")
        }</span>

        <span class="cov8" title="1">attendanceID, _ := result.LastInsertId()

        // Create exception if late
        if isLate </span><span class="cov0" title="0">{
                _ = s.queries.CreateAttendanceException(ctx, sqlc.CreateAttendanceExceptionParams{
                        AttendanceID:  uint64(attendanceID),
                        ExceptionType: sqlc.AttendanceExceptionsExceptionTypeLateCheckin,
                        Severity:      sqlc.AttendanceExceptionsSeverityWarning,
                        AutoFlagged:   true,
                })
        }</span>

        // Audit log
        <span class="cov8" title="1">s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                Type:     "attendance",
                Action:   "check_in",
                UserID:   userID,
                Resource: fmt.Sprintf("attendance:%d", attendanceID),
                Success:  true,
        })

        // Fetch and return created record
        attendance, err := s.queries.GetAttendanceByID(ctx, uint64(attendanceID))
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to fetch created attendance")
        }</span>

        <span class="cov8" title="1">return s.toAttendanceResponse(attendance), nil</span>
}

// CheckOut closes an attendance session
func (s *Service) CheckOut(ctx context.Context, userID uint64, req CheckOutRequest) (*AttendanceResponse, error) <span class="cov8" title="1">{
        now := time.Now().UTC()

        // Validate client timestamp skew
        if req.ClientTimestamp != nil </span><span class="cov8" title="1">{
                skew := now.Sub(*req.ClientTimestamp).Abs()
                if skew &gt; 5*time.Minute </span><span class="cov0" title="0">{
                        return nil, ErrTimeSkewTooLarge
                }</span>
        }

        // Find session to close
        <span class="cov8" title="1">var attendance sqlc.AttendanceRecord
        var err error
        if req.AttendanceID != nil </span><span class="cov8" title="1">{
                attendance, err = s.queries.GetAttendanceByID(ctx, *req.AttendanceID)
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrSessionNotFound
                }</span>
        } else<span class="cov8" title="1"> {
                // Find latest open session
                openSession, err := s.queries.GetOpenAttendanceForUser(ctx, userID)
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrNoOpenSession
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return nil, WrapAttendanceError(err, "Failed to find open session")
                }</span>
                <span class="cov8" title="1">attendance = openSession</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to fetch attendance")
        }</span>

        // Verify ownership
        <span class="cov8" title="1">if attendance.UserID != userID </span><span class="cov8" title="1">{
                return nil, errors.ErrForbidden
        }</span>

        // Check if already checked out
        <span class="cov8" title="1">if attendance.CheckOutAt.Valid </span><span class="cov8" title="1">{
                return nil, ErrAlreadyCheckedOut
        }</span>

        // Calculate duration
        <span class="cov8" title="1">duration := uint32(now.Sub(attendance.CheckInAt).Seconds())

        // Calculate overtime if shift assigned
        overtime := uint32(0)
        isEarlyLeave := false
        if attendance.ShiftID.Valid </span><span class="cov8" title="1">{
                shift, err := s.queries.GetShift(ctx, uint64(attendance.ShiftID.Int64))
                if err == nil </span><span class="cov8" title="1">{
                        shiftDuration := s.calculateShiftDuration(shift.StartTime, shift.EndTime, uint32(shift.BreakMinutes))
                        if duration &gt; shiftDuration </span><span class="cov8" title="1">{
                                overtime = duration - shiftDuration
                        }</span>
                        // Check early leave
                        <span class="cov8" title="1">shiftEnd, _ := time.Parse("15:04:05", shift.EndTime.Format("15:04:05"))
                        expectedEnd := time.Date(now.Year(), now.Month(), now.Day(), shiftEnd.Hour(), shiftEnd.Minute(), 0, 0, time.UTC)
                        if now.Before(expectedEnd.Add(-5 * time.Minute)) </span><span class="cov8" title="1">{
                                isEarlyLeave = true
                        }</span>
                }
        }

        // Safely handle optional fields to avoid nil pointer dereference
        <span class="cov8" title="1">var checkOutLat, checkOutLng sql.NullString
        if req.Latitude != nil </span><span class="cov8" title="1">{
                checkOutLat = sql.NullString{Valid: true, String: fmt.Sprintf("%f", *req.Latitude)}
        }</span>
        <span class="cov8" title="1">if req.Longitude != nil </span><span class="cov8" title="1">{
                checkOutLng = sql.NullString{Valid: true, String: fmt.Sprintf("%f", *req.Longitude)}
        }</span>

        <span class="cov8" title="1">var clientCheckOutAt sql.NullTime
        if req.ClientTimestamp != nil </span><span class="cov8" title="1">{
                clientCheckOutAt = sql.NullTime{Valid: true, Time: *req.ClientTimestamp}
        }</span>

        // Update attendance
        <span class="cov8" title="1">err = s.queries.CloseAttendance(ctx, sqlc.CloseAttendanceParams{
                ID:               attendance.ID,
                CheckOutAt:       sql.NullTime{Valid: true, Time: now},
                DurationSeconds:  sql.NullInt32{Valid: true, Int32: int32(duration)},
                OvertimeSeconds:  sql.NullInt32{Valid: true, Int32: int32(overtime)},
                CheckOutLat:      checkOutLat,
                CheckOutLng:      checkOutLng,
                ClientCheckOutAt: clientCheckOutAt,
                IsEarlyLeave:     isEarlyLeave,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to update attendance")
        }</span>

        // Create exception if early leave
        <span class="cov8" title="1">if isEarlyLeave </span><span class="cov8" title="1">{
                _ = s.queries.CreateAttendanceException(ctx, sqlc.CreateAttendanceExceptionParams{
                        AttendanceID:  attendance.ID,
                        ExceptionType: sqlc.AttendanceExceptionsExceptionTypeEarlyCheckout,
                        Severity:      sqlc.AttendanceExceptionsSeverityWarning,
                        AutoFlagged:   true,
                })
        }</span>

        // Audit log
        <span class="cov8" title="1">s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                Type:     "attendance",
                Action:   "check_out",
                UserID:   userID,
                Resource: fmt.Sprintf("attendance:%d", attendance.ID),
                Success:  true,
        })

        // Return updated record
        updated, err := s.queries.GetAttendanceByID(ctx, attendance.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to fetch updated attendance record")
        }</span>
        <span class="cov8" title="1">return s.toAttendanceResponse(updated), nil</span>
}

// ListAttendance retrieves attendance records with filters
func (s *Service) ListAttendance(ctx context.Context, req ListAttendanceRequest) (*ListAttendanceResponse, error) <span class="cov8" title="1">{
        if req.Limit &lt;= 0 </span><span class="cov8" title="1">{
                req.Limit = 20
        }</span>
        <span class="cov8" title="1">if req.Page &lt;= 0 </span><span class="cov8" title="1">{
                req.Page = 1
        }</span>
        <span class="cov8" title="1">offset := (req.Page - 1) * req.Limit

        // Use zero values for optional filters
        userID := uint64(0)
        if req.UserID != nil </span><span class="cov8" title="1">{
                userID = *req.UserID
        }</span>

        <span class="cov8" title="1">var from, to *time.Time
        if req.From != nil </span><span class="cov8" title="1">{
                from = req.From
        }</span>
        <span class="cov8" title="1">if req.To != nil </span><span class="cov8" title="1">{
                to = req.To
        }</span>

        // Initialize with empty filters
        <span class="cov8" title="1">params := sqlc.CountAttendanceParams{
                Column1:     0,
                UserID:      0,
                Column3:     nil,
                CheckInAt:   time.Time{},
                Column5:     nil,
                CheckInAt_2: time.Time{},
                Column7:     "",
                Status:      "",
                Column9:     0,
                ShiftID:     sql.NullInt64{},
        }

        // Apply filters conditionally
        if userID &gt; 0 </span><span class="cov8" title="1">{
                params.Column1 = 1
                params.UserID = userID
        }</span>

        <span class="cov8" title="1">if from != nil </span><span class="cov8" title="1">{
                params.Column3 = from
                params.CheckInAt = *from
        }</span>

        <span class="cov8" title="1">if to != nil </span><span class="cov8" title="1">{
                params.Column5 = to
                params.CheckInAt_2 = *to
        }</span>

        <span class="cov8" title="1">if req.Status != "" </span><span class="cov8" title="1">{
                params.Column7 = req.Status
        }</span>

        <span class="cov8" title="1">if req.ShiftID != nil </span><span class="cov8" title="1">{
                params.Column9 = 1
                params.ShiftID = sql.NullInt64{Valid: true, Int64: int64(*req.ShiftID)}
        }</span>

        // Count total
        <span class="cov8" title="1">total, err := s.queries.CountAttendance(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to count attendance")
        }</span>

        // Fetch records
        <span class="cov8" title="1">records, err := s.queries.ListAttendance(ctx, sqlc.ListAttendanceParams{
                Column1:     params.Column1,
                UserID:      params.UserID,
                Column3:     params.Column3,
                CheckInAt:   params.CheckInAt,
                Column5:     params.Column5,
                CheckInAt_2: params.CheckInAt_2,
                Column7:     params.Column7,
                Status:      params.Status,
                Column9:     params.Column9,
                ShiftID:     params.ShiftID,
                Limit:       int32(req.Limit),
                Offset:      int32(offset),
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to list attendance")
        }</span>

        <span class="cov8" title="1">responses := make([]AttendanceResponse, len(records))
        for i, rec := range records </span><span class="cov8" title="1">{
                responses[i] = AttendanceResponse{
                        ID:              rec.ID,
                        UserID:          rec.UserID,
                        ShiftID:         toUint64Ptr(rec.ShiftID),
                        CheckInAt:       rec.CheckInAt,
                        CheckOutAt:      toTimePtr(rec.CheckOutAt),
                        DurationSeconds: toUint32Ptr(rec.DurationSeconds),
                        OvertimeSeconds: uint32(rec.OvertimeSeconds.Int32),
                        Status:          string(rec.Status),
                        IsLate:          rec.IsLate,
                        IsEarlyLeave:    rec.IsEarlyLeave,
                        CreatedAt:       rec.CreatedAt,
                        UpdatedAt:       rec.UpdatedAt,
                }
        }</span>

        <span class="cov8" title="1">return &amp;ListAttendanceResponse{
                Records: responses,
                Total:   total,
                Page:    req.Page,
                Limit:   req.Limit,
        }, nil</span>
}

// AutoCheckoutStaleSessions closes sessions older than threshold
func (s *Service) AutoCheckoutStaleSessions(ctx context.Context, olderThanHours int) (int64, error) <span class="cov8" title="1">{
        result, err := s.queries.AutoCloseStaleAttendance(ctx, olderThanHours)
        if err != nil </span><span class="cov8" title="1">{
                return 0, WrapAttendanceError(err, "Failed to auto-close stale sessions")
        }</span>

        <span class="cov8" title="1">count, _ := result.RowsAffected()
        s.logger.Info(ctx, fmt.Sprintf("Auto-closed %d stale attendance sessions", count))
        return count, nil</span>
}

// GetLeaveBalance calculates leave balance for user
func (s *Service) GetLeaveBalance(ctx context.Context, userID uint64, leaveType string) (*LeaveBalanceResponse, error) <span class="cov8" title="1">{
        year := time.Now().Year()
        var sqlLeaveType sqlc.LeaveAccrualsLeaveType
        switch leaveType </span>{
        case "sick":<span class="cov8" title="1">
                sqlLeaveType = sqlc.LeaveAccrualsLeaveTypeSick</span>
        case "vacation":<span class="cov8" title="1">
                sqlLeaveType = sqlc.LeaveAccrualsLeaveTypeVacation</span>
        case "personal":<span class="cov8" title="1">
                sqlLeaveType = sqlc.LeaveAccrualsLeaveTypePersonal</span>
        default:<span class="cov8" title="1">
                return nil, errors.New(errors.ErrCodeValidation, "Invalid leave type")</span>
        }

        <span class="cov8" title="1">balance, err := s.queries.GetLeaveBalance(ctx, sqlc.GetLeaveBalanceParams{
                UserID:    userID,
                LeaveType: sqlLeaveType,
                Year:      uint32(year),
        })
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                // Initialize with defaults
                return &amp;LeaveBalanceResponse{
                        LeaveType:     leaveType,
                        AccruedDays:   0,
                        UsedDays:      0,
                        CarryoverDays: 0,
                        AvailableDays: 0,
                        Year:          year,
                }, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to fetch leave balance")
        }</span>

        // Convert string values to float64
        <span class="cov8" title="1">accruedDays, _ := convertToFloat(balance.AccruedDays)
        usedDays, _ := convertToFloat(balance.UsedDays)
        carryoverDays, _ := convertToFloat(balance.CarryoverDays)
        available := accruedDays + carryoverDays - usedDays

        return &amp;LeaveBalanceResponse{
                LeaveType:     string(balance.LeaveType),
                AccruedDays:   accruedDays,
                UsedDays:      usedDays,
                CarryoverDays: carryoverDays,
                AvailableDays: available,
                Year:          int(balance.Year),
        }, nil</span>
}

// RequestTimeOff creates a new time off request
func (s *Service) RequestTimeOff(ctx context.Context, userID uint64, req TimeOffRequest) (uint64, error) <span class="cov8" title="1">{
        var leaveType sqlc.TimeOffRequestsLeaveType
        switch req.LeaveType </span>{
        case "sick":<span class="cov8" title="1">
                leaveType = sqlc.TimeOffRequestsLeaveTypeSick</span>
        case "vacation":<span class="cov8" title="1">
                leaveType = sqlc.TimeOffRequestsLeaveTypeVacation</span>
        case "personal":<span class="cov8" title="1">
                leaveType = sqlc.TimeOffRequestsLeaveTypePersonal</span>
        case "unpaid":<span class="cov8" title="1">
                leaveType = sqlc.TimeOffRequestsLeaveTypeUnpaid</span>
        default:<span class="cov0" title="0">
                return 0, errors.New(errors.ErrCodeValidation, "Invalid leave type")</span>
        }

        <span class="cov8" title="1">startDate, err := time.Parse("2006-01-02", req.StartDate)
        if err != nil </span><span class="cov8" title="1">{
                return 0, errors.New(errors.ErrCodeValidation, "Invalid start date format")
        }</span>

        <span class="cov8" title="1">endDate, err := time.Parse("2006-01-02", req.EndDate)
        if err != nil </span><span class="cov8" title="1">{
                return 0, errors.New(errors.ErrCodeValidation, "Invalid end date format")
        }</span>

        <span class="cov8" title="1">daysCount := calculateBusinessDays(startDate, endDate)

        result, err := s.queries.CreateTimeOffRequest(ctx, sqlc.CreateTimeOffRequestParams{
                UserID:    userID,
                LeaveType: leaveType,
                StartDate: startDate,
                EndDate:   endDate,
                DaysCount: fmt.Sprintf("%.2f", daysCount),
                Reason:    sql.NullString{Valid: true, String: req.Reason},
                Status:    sqlc.TimeOffRequestsStatusPending,
        })
        if err != nil </span><span class="cov8" title="1">{
                return 0, WrapAttendanceError(err, "Failed to create time off request")
        }</span>

        <span class="cov8" title="1">timeOffID, _ := result.LastInsertId()
        return uint64(timeOffID), nil</span>
}

// Helper functions
func (s *Service) toAttendanceResponse(a sqlc.AttendanceRecord) *AttendanceResponse <span class="cov8" title="1">{
        return &amp;AttendanceResponse{
                ID:                a.ID,
                UserID:            a.UserID,
                ShiftID:           toUint64Ptr(a.ShiftID),
                CheckInAt:         a.CheckInAt,
                CheckOutAt:        toTimePtr(a.CheckOutAt),
                DurationSeconds:   toUint32Ptr(a.DurationSeconds),
                OvertimeSeconds:   uint32(a.OvertimeSeconds.Int32),
                Status:            string(a.Status),
                IsLate:            a.IsLate,
                IsEarlyLeave:      a.IsEarlyLeave,
                CheckInLatitude:   toFloat64PtrFromString(a.CheckInLat),
                CheckInLongitude:  toFloat64PtrFromString(a.CheckInLng),
                CheckOutLatitude:  toFloat64PtrFromString(a.CheckOutLat),
                CheckOutLongitude: toFloat64PtrFromString(a.CheckOutLng),
                CreatedAt:         a.CreatedAt,
                UpdatedAt:         a.UpdatedAt,
        }
}</span>

func (s *Service) calculateShiftDuration(start, end time.Time, breakMinutes uint32) uint32 <span class="cov8" title="1">{
        duration := end.Sub(start).Seconds()
        return uint32(duration) - (breakMinutes * 60)
}</span>

func toUint64Ptr(val sql.NullInt64) *uint64 <span class="cov8" title="1">{
        if val.Valid </span><span class="cov8" title="1">{
                u := uint64(val.Int64)
                return &amp;u
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func toTimePtr(val sql.NullTime) *time.Time <span class="cov8" title="1">{
        if val.Valid </span><span class="cov8" title="1">{
                return &amp;val.Time
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func toUint32Ptr(val sql.NullInt32) *uint32 <span class="cov8" title="1">{
        if val.Valid </span><span class="cov8" title="1">{
                u := uint32(val.Int32)
                return &amp;u
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func toFloat64PtrFromString(val sql.NullString) *float64 <span class="cov8" title="1">{
        if val.Valid </span><span class="cov8" title="1">{
                var f float64
                fmt.Sscanf(val.String, "%f", &amp;f)
                return &amp;f
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func calculateBusinessDays(start, end time.Time) float64 <span class="cov8" title="1">{
        if start.After(end) </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">totalDays := 0.0
        current := time.Date(start.Year(), start.Month(), start.Day(), 0, 0, 0, 0, start.Location())
        endDateOnly := time.Date(end.Year(), end.Month(), end.Day(), 0, 0, 0, 0, end.Location())

        for !current.After(endDateOnly) </span><span class="cov8" title="1">{
                // Skip weekends (Saturday and Sunday)
                if current.Weekday() != time.Saturday &amp;&amp; current.Weekday() != time.Sunday </span><span class="cov8" title="1">{
                        if current.Equal(time.Date(start.Year(), start.Month(), start.Day(), 0, 0, 0, 0, start.Location())) &amp;&amp;
                                current.Equal(endDateOnly) </span><span class="cov8" title="1">{
                                // Same day leave
                                hours := end.Sub(start).Hours()
                                totalDays += math.Min(1.0, hours/8.0)
                        }</span> else<span class="cov8" title="1"> if current.Equal(time.Date(start.Year(), start.Month(), start.Day(), 0, 0, 0, 0, start.Location())) </span><span class="cov8" title="1">{
                                // First day of multi-day leave (from start time to end of day)
                                dayEnd := time.Date(start.Year(), start.Month(), start.Day(), 17, 0, 0, 0, start.Location())
                                hours := dayEnd.Sub(start).Hours()
                                totalDays += math.Min(1.0, math.Max(0.5, hours/8.0))
                        }</span> else<span class="cov8" title="1"> if current.Equal(endDateOnly) </span><span class="cov8" title="1">{
                                // Last day of multi-day leave (from start of day to end time)
                                dayStart := time.Date(end.Year(), end.Month(), end.Day(), 9, 0, 0, 0, end.Location())
                                hours := end.Sub(dayStart).Hours()
                                totalDays += math.Min(1.0, math.Max(0.5, hours/8.0))
                        }</span> else<span class="cov8" title="1"> {
                                // Full middle day
                                totalDays += 1.0
                        }</span>
                }
                <span class="cov8" title="1">current = current.AddDate(0, 0, 1)</span>
        }
        <span class="cov8" title="1">return math.Max(totalDays, 0.5)</span>
}

func convertToFloat(val string) (float64, error) <span class="cov8" title="1">{
        if val == "" </span><span class="cov8" title="1">{
                return 0.0, nil
        }</span>

        <span class="cov8" title="1">var f float64
        _, err := fmt.Sscanf(val, "%f", &amp;f)
        return f, err</span>
}

// DailySummary retrieves attendance summary for a specific date
func (s *Service) DailySummary(ctx context.Context, date time.Time) (*DailySummaryResponse, error) <span class="cov8" title="1">{
        rows, err := s.queries.DailySummary(ctx, date)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, WrapAttendanceError(err, "Failed to fetch daily summary")
        }</span>

        <span class="cov8" title="1">if len(rows) == 0 || err == sql.ErrNoRows </span><span class="cov8" title="1">{
                // If no attendance records for the date, return empty summary
                return &amp;DailySummaryResponse{
                        Date: date.Format("2006-01-02"),
                }, nil
        }</span>

        <span class="cov8" title="1">row := rows[0]

        // Helper function to safely convert interface{} to float64
        toFloat64 := func(val interface{}) float64 </span><span class="cov8" title="1">{
                if val == nil </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov8" title="1">switch v := val.(type) </span>{
                case int64:<span class="cov8" title="1">
                        return float64(v)</span>
                case float64:<span class="cov0" title="0">
                        return v</span>
                default:<span class="cov0" title="0">
                        return 0</span>
                }
        }

        // Helper function to safely convert interface{} to int
        <span class="cov8" title="1">toInt := func(val interface{}) int </span><span class="cov8" title="1">{
                if val == nil </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov8" title="1">switch v := val.(type) </span>{
                case int64:<span class="cov8" title="1">
                        return int(v)</span>
                default:<span class="cov0" title="0">
                        return 0</span>
                }
        }

        // Convert seconds to hours
        <span class="cov8" title="1">totalHours := toFloat64(row.TotalSeconds) / 3600.0
        overtimeHours := toFloat64(row.TotalOvertimeSeconds) / 3600.0

        return &amp;DailySummaryResponse{
                Date:               date.Format("2006-01-02"),
                TotalAttendance:    int(row.TotalAttendance),
                PresentCount:       toInt(row.PresentCount),
                OnLeaveCount:       toInt(row.OnLeaveCount),
                AbsentCount:        toInt(row.AbsentCount),
                LateCount:          toInt(row.LateCount),
                TotalHours:         totalHours,
                TotalOvertimeHours: overtimeHours,
        }, nil</span>
}

// ExportTimesheetForPeriod exports timesheet data for an employee for a specific period
func (s *Service) ExportTimesheetForPeriod(ctx context.Context, employeeID uint64, startDate, endDate time.Time) ([]sqlc.ExportTimesheetForPeriodRow, error) <span class="cov8" title="1">{
        params := sqlc.ExportTimesheetForPeriodParams{
                CheckInAt:   startDate,
                CheckInAt_2: endDate,
                Column3:     1, // Enable user filter
                UserID:      employeeID,
        }

        return s.queries.ExportTimesheetForPeriod(ctx, params)
}</span>

func (s *Service) ApproveTimeOff(ctx context.Context, requestID uint64, adminID uint64, note string) error <span class="cov8" title="1">{
        request, err := s.queries.GetTimeOffByID(ctx, requestID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return errors.ErrNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">if request.Status != "pending" </span><span class="cov8" title="1">{
                return errors.New(errors.ErrInvalidStatus, "Only pending requests can be approved")
        }</span>

        <span class="cov8" title="1">err = s.queries.ApproveTimeOff(ctx, sqlc.ApproveTimeOffParams{
                ID:         requestID,
                ReviewedBy: sql.NullInt64{Int64: int64(adminID), Valid: true},
                ReviewNote: sql.NullString{String: note, Valid: true},
        })

        if err == nil </span><span class="cov8" title="1">{
                s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                        Type: "attendance", Action: "approve_time_off", UserID: adminID, Resource: "time_off", Success: true,
                })
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (s *Service) RejectTimeOff(ctx context.Context, requestID uint64, adminID uint64, note string) error <span class="cov8" title="1">{
        request, err := s.queries.GetTimeOffByID(ctx, requestID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return errors.ErrNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">if request.Status != "pending" </span><span class="cov8" title="1">{
                return errors.New(errors.ErrInvalidStatus, "Only pending requests can be rejected")
        }</span>

        <span class="cov8" title="1">return s.queries.RejectTimeOff(ctx, sqlc.RejectTimeOffParams{
                ID:         requestID,
                ReviewedBy: sql.NullInt64{Int64: int64(adminID), Valid: true},
                ReviewNote: sql.NullString{String: note, Valid: true},
        })</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package auth

import (
        "database/sql"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
        "github.com/waqasmani/go-boilerplate/internal/shared/utils"
        "github.com/waqasmani/go-boilerplate/internal/shared/validator"
)

type Handler struct {
        service *Service
}

func NewHandler(service *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{service: service}
}</span>

type RegisterRequest struct {
        Email     string `json:"email" validate:"required,email"`
        Password  string `json:"password" validate:"required,min=8"`
        FirstName string `json:"first_name" validate:"required"`
        LastName  string `json:"last_name" validate:"required"`
}

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

type UserResponse struct {
        ID        uint64    `json:"id"`
        Email     string    `json:"email"`
        FirstName string    `json:"first_name"`
        LastName  string    `json:"last_name"`
        Role      string    `json:"role"`
        CreatedAt time.Time `json:"created_at"`
}

type AuthResponse struct {
        AccessToken string       `json:"access_token"`
        User        UserResponse `json:"user"`
}

// Register godoc
// @Summary Register a new user
// @Description Create a new user account
// @Tags Authentication
// @Accept json
// @Produce json
// @Param body body RegisterRequest true "User registration details"
// @Success 201 {object} utils.Response{data=UserResponse}
// @Failure 400 {object} utils.Response
// @Failure 409 {object} utils.Response
// @Router /auth/register [post]
func (h *Handler) Register(c *gin.Context) <span class="cov8" title="1">{
        var req RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov8" title="1">if err := h.service.validator.Validate(req); err != nil </span><span class="cov8" title="1">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov8" title="1">user, err := h.service.Register(c.Request.Context(), req.Email, req.Password, req.FirstName, req.LastName)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">utils.Success(c, http.StatusCreated, UserResponse{
                ID:        user.ID,
                Email:     user.Email,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                Role:      user.Role,
                CreatedAt: user.CreatedAt,
        })</span>
}

// Login godoc
// @Summary Login to get access token
// @Description Authenticate user and return access token
// @Tags Authentication
// @Accept json
// @Produce json
// @Param body body LoginRequest true "User credentials"
// @Success 200 {object} utils.Response{data=AuthResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Router /auth/login [post]
func (h *Handler) Login(c *gin.Context) <span class="cov8" title="1">{
        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov8" title="1">if err := h.service.validator.Validate(req); err != nil </span><span class="cov8" title="1">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov8" title="1">loginCtx := LoginContext{
                ClientIP:  getClientIP(c),
                UserAgent: c.Request.UserAgent(),
        }

        accessToken, refreshToken, csrfToken, user, err := h.service.Login(c.Request.Context(), req.Email, req.Password, loginCtx)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">isSecure := h.service.cfg.Server.Env == "production"
        c.SetSameSite(http.SameSiteLaxMode)
        c.SetCookie(
                "refresh_token",
                refreshToken,
                int(h.service.jwtService.GetRefreshExpiry().Seconds()),
                "/api/v1/auth/refresh",
                "",
                isSecure,
                true,
        )

        c.Header("X-CSRF-Token", csrfToken)

        utils.Success(c, http.StatusOK, AuthResponse{
                AccessToken: accessToken,
                User: UserResponse{
                        ID:        user.ID,
                        Email:     user.Email,
                        FirstName: user.FirstName,
                        LastName:  user.LastName,
                        Role:      user.Role,
                        CreatedAt: user.CreatedAt,
                },
        })</span>
}

// Refresh godoc
// @Summary Refresh access token
// @Description Get a new access token using refresh token
// @Tags Authentication
// @Accept json
// @Produce json
// @Success 200 {object} utils.Response{data=AuthResponse}
// @Failure 401 {object} utils.Response
// @Security     CsrfToken
// @Router /auth/refresh [post]
func (h *Handler) Refresh(c *gin.Context) <span class="cov8" title="1">{
        refreshToken, err := c.Cookie("refresh_token")
        if err != nil </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeUnauthorized, "Refresh token not found"))
                return
        }</span>

        <span class="cov8" title="1">csrfToken := c.GetHeader("X-CSRF-Token")
        if csrfToken == "" </span><span class="cov8" title="1">{
                utils.Error(c, errors.New(errors.ErrCodeUnauthorized, "CSRF token required"))
                return
        }</span>

        <span class="cov8" title="1">loginCtx := LoginContext{
                ClientIP:  getClientIP(c),
                UserAgent: c.Request.UserAgent(),
        }

        accessToken, newRefreshToken, newCsrfToken, user, err := h.service.RefreshToken(c.Request.Context(), refreshToken, csrfToken, loginCtx)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">isSecure := h.service.cfg.Server.Env == "production"
        c.SetSameSite(http.SameSiteLaxMode)
        c.SetCookie(
                "refresh_token",
                newRefreshToken,
                int(h.service.jwtService.GetRefreshExpiry().Seconds()),
                "/api/v1/auth/refresh",
                "",
                isSecure,
                true,
        )

        c.Header("X-CSRF-Token", newCsrfToken)

        utils.Success(c, http.StatusOK, AuthResponse{
                AccessToken: accessToken,
                User: UserResponse{
                        ID:        user.ID,
                        Email:     user.Email,
                        FirstName: user.FirstName,
                        LastName:  user.LastName,
                        Role:      user.Role,
                        CreatedAt: user.CreatedAt,
                },
        })</span>
}

// Logout godoc
// @Summary Logout user
// @Description Invalidate refresh token
// @Tags Authentication
// @Accept json
// @Produce json
// @Success 204
// @Failure 401 {object} utils.Response
// @Security     Bearer
// @Router /auth/logout [post]
func (h *Handler) Logout(c *gin.Context) <span class="cov8" title="1">{
        refreshToken, err := c.Cookie("refresh_token")
        if err == nil &amp;&amp; refreshToken != "" </span><span class="cov8" title="1">{
                _ = h.service.Logout(c.Request.Context(), refreshToken)
        }</span>

        <span class="cov8" title="1">c.SetCookie(
                "refresh_token",
                "",
                -1,
                "/api/v1/auth/refresh",
                "",
                h.service.cfg.Server.Env == "production",
                true,
        )

        c.Status(http.StatusNoContent)</span>
}

// Me godoc
// @Summary Get current user
// @Description Get information about the currently authenticated user
// @Tags Authentication
// @Accept json
// @Produce json
// @Success 200 {object} utils.Response{data=UserResponse}
// @Failure 401 {object} utils.Response
// @Security     Bearer
// @Router /auth/me [get]
func (h *Handler) Me(c *gin.Context) <span class="cov8" title="1">{
        userID, err := middleware.GetCurrentUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov8" title="1">user, err := h.service.queries.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        utils.Error(c, errors.ErrNotFound)
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(c, errors.Wrap(err, errors.ErrCodeInternal, "Failed to fetch user"))
                return</span>
        }

        <span class="cov8" title="1">utils.Success(c, http.StatusOK, UserResponse{
                ID:        user.ID,
                Email:     user.Email,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                Role:      user.Role,
                CreatedAt: user.CreatedAt,
        })</span>
}

func getClientIP(c *gin.Context) string <span class="cov8" title="1">{
        // Try to get real IP from proxy headers
        if ip := c.GetHeader("X-Real-IP"); ip != "" </span><span class="cov8" title="1">{
                return ip
        }</span>
        <span class="cov8" title="1">if ip := c.GetHeader("X-Forwarded-For"); ip != "" </span><span class="cov8" title="1">{
                // X-Forwarded-For can contain multiple IPs, get the first one
                parts := strings.Split(ip, ",")
                if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                        return strings.TrimSpace(parts[0])
                }</span>
        }
        // Fallback to RemoteAddr
        <span class="cov8" title="1">return c.ClientIP()</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package auth

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/security"
)

func RegisterRoutes(router *gin.Engine, handler *Handler, authMiddleware *middleware.AuthMiddleware, rateLimiter security.RateLimiter) <span class="cov8" title="1">{
        authGroup := router.Group("/api/v1/auth")
        </span><span class="cov8" title="1">{
                authGroup.POST("/register",
                        security.RouteRateLimitMiddleware(rateLimiter, 5, time.Minute),
                        handler.Register,
                )

                authGroup.POST("/login",
                        security.RouteRateLimitMiddleware(rateLimiter, 5, time.Minute),
                        handler.Login,
                )

                authGroup.POST("/refresh",
                        security.RouteRateLimitMiddleware(rateLimiter, 10, time.Minute),
                        handler.Refresh,
                )

                authGroup.POST("/logout",
                        authMiddleware.Authenticate(),
                        handler.Logout,
                )

                authGroup.GET("/me",
                        authMiddleware.Authenticate(),
                        handler.Me,
                )
        }</span>
}</pre>
		
		<pre class="file" id="file29" style="display: none">package auth

import (
        "context"
        "database/sql"
        "time"

        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/security"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/sqlc"
        apperrors "github.com/waqasmani/go-boilerplate/internal/shared/errors"
        "github.com/waqasmani/go-boilerplate/internal/shared/validator"
)

type Service struct {
        queries         *sqlc.Queries
        repo            *sqlc.Repository
        jwtService      *security.JWTService
        passwordService *security.PasswordService
        validator       *validator.Validator
        auditLogger     *observability.AuditLogger
        metrics         *observability.Metrics
        cfg             *config.Config
        logger          *observability.Logger
}

type LoginContext struct {
        ClientIP  string
        UserAgent string
}

func NewService(
        queries *sqlc.Queries,
        repo *sqlc.Repository,
        jwtService *security.JWTService,
        passwordService *security.PasswordService,
        validator *validator.Validator,
        auditLogger *observability.AuditLogger,
        metrics *observability.Metrics,
        cfg *config.Config,
        logger *observability.Logger,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                queries:         queries,
                repo:            repo,
                jwtService:      jwtService,
                passwordService: passwordService,
                validator:       validator,
                auditLogger:     auditLogger,
                metrics:         metrics,
                cfg:             cfg,
                logger:          logger,
        }
}</span>

func (s *Service) Register(ctx context.Context, email, password, firstName, lastName string) (*sqlc.User, error) <span class="cov8" title="1">{
        existingUser, err := s.queries.GetUserByEmail(ctx, email)
        if err == nil &amp;&amp; existingUser.ID &gt; 0 </span><span class="cov8" title="1">{
                return nil, apperrors.New(apperrors.ErrCodeConflict, "Email already registered")
        }</span>

        <span class="cov8" title="1">if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to check existing user")
        }</span>

        <span class="cov8" title="1">passwordHash, err := s.passwordService.Hash(ctx, password)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeValidation, "Invalid password")
        }</span>

        <span class="cov8" title="1">result, err := s.queries.CreateUser(ctx, sqlc.CreateUserParams{
                Email:        email,
                PasswordHash: passwordHash,
                FirstName:    firstName,
                LastName:     lastName,
                Role:         "user",
                IsActive:     true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to create user")
        }</span>

        <span class="cov8" title="1">userID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to get user ID")
        }</span>

        <span class="cov8" title="1">user, err := s.queries.GetUserByID(ctx, uint64(userID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to fetch created user")
        }</span>

        <span class="cov8" title="1">s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                Type:     "auth",
                Action:   "register",
                UserID:   user.ID,
                Resource: "user",
                Success:  true,
        })

        s.metrics.AuthenticationAttempts.WithLabelValues("register").Inc()
        return &amp;user, nil</span>
}

func (s *Service) Login(ctx context.Context, email, password string, loginCtx LoginContext) (string, string, string, *sqlc.User, error) <span class="cov8" title="1">{
        s.metrics.AuthenticationAttempts.WithLabelValues("login").Inc()

        // Check if account is locked
        lockoutInfo, err := s.checkAccountLockout(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", nil, err
        }</span>

        <span class="cov8" title="1">if lockoutInfo.IsLocked </span><span class="cov8" title="1">{
                s.metrics.AuthenticationFailures.WithLabelValues("login", "account_locked").Inc()
                return "", "", "", nil, apperrors.WithDetails(
                        apperrors.ErrCodeForbidden,
                        "Account temporarily locked due to multiple failed login attempts",
                        map[string]interface{}{
                                "retry_after_seconds": lockoutInfo.RetryAfterSeconds,
                                "attempts_remaining":  0,
                        },
                )
        }</span>

        <span class="cov8" title="1">user, err := s.queries.GetUserByEmail(ctx, email)
        const dummyHash = "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgNI1S8p/8A8z7E83C5U6uL6CjX6"
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        _ = s.passwordService.Compare(ctx, dummyHash, password)
                        return "", "", "", nil, apperrors.ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">return "", "", "", nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Authentication failed")</span>
        }

        <span class="cov8" title="1">if err := s.passwordService.Compare(ctx, user.PasswordHash, password); err != nil </span><span class="cov8" title="1">{
                s.recordFailedLogin(ctx, user.ID, email, loginCtx.ClientIP)
                s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                        Type:      "auth",
                        Action:    "login_failed",
                        UserID:    user.ID,
                        Resource:  "user",
                        Success:   false,
                        IPAddress: loginCtx.ClientIP,
                })
                s.metrics.AuthenticationFailures.WithLabelValues("login", "invalid_credentials").Inc()

                // Check if this failure causes lockout
                updatedLockoutInfo, _ := s.checkAccountLockout(ctx, email)
                if updatedLockoutInfo.IsLocked </span><span class="cov8" title="1">{
                        return "", "", "", nil, apperrors.WithDetails(
                                apperrors.ErrCodeForbidden,
                                "Account locked due to multiple failed login attempts",
                                map[string]interface{}{
                                        "retry_after_seconds": updatedLockoutInfo.RetryAfterSeconds,
                                },
                        )
                }</span>
                <span class="cov8" title="1">return "", "", "", nil, apperrors.WithDetails(
                        apperrors.ErrCodeUnauthorized,
                        "Invalid credentials",
                        map[string]interface{}{
                                "attempts_remaining": s.cfg.Security.MaxLoginAttempts - updatedLockoutInfo.FailedAttempts,
                        },
                )</span>
        }

        // Clear failed attempts on successful login
        <span class="cov8" title="1">s.queries.ClearFailedLoginAttempts(ctx, email)

        accessToken, err := s.jwtService.GenerateAccessToken(ctx, user.ID, user.Email, user.Role)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to generate access token")
        }</span>

        <span class="cov8" title="1">rawRefreshToken, refreshTokenHash, err := s.jwtService.GenerateStateToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to generate refresh token")
        }</span>

        <span class="cov8" title="1">rawCsrfToken, csrfTokenHash, err := s.jwtService.GenerateStateToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to generate CSRF token")
        }</span>

        <span class="cov8" title="1">err = s.queries.CreateRefreshToken(ctx, sqlc.CreateRefreshTokenParams{
                UserID:    user.ID,
                TokenHash: refreshTokenHash,
                CsrfHash:  csrfTokenHash,
                ClientIp: sql.NullString{
                        String: loginCtx.ClientIP,
                        Valid:  s.cfg.Security.SessionBindingEnabled &amp;&amp; loginCtx.ClientIP != "",
                },
                UserAgent: sql.NullString{
                        String: loginCtx.UserAgent,
                        Valid:  s.cfg.Security.SessionBindingEnabled &amp;&amp; loginCtx.UserAgent != "",
                },
                ExpiresAt: time.Now().Add(s.jwtService.GetRefreshExpiry()),
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to store refresh token")
        }</span>

        <span class="cov8" title="1">s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                Type:      "auth",
                Action:    "login",
                UserID:    user.ID,
                Resource:  "user",
                Success:   true,
                IPAddress: loginCtx.ClientIP,
        })

        return accessToken, rawRefreshToken, rawCsrfToken, &amp;user, nil</span>
}

func (s *Service) RefreshToken(ctx context.Context, refreshToken, csrfToken string, loginCtx LoginContext) (string, string, string, *sqlc.User, error) <span class="cov8" title="1">{
        s.metrics.TokenRefreshes.WithLabelValues("attempted").Inc()

        refreshTokenHash := s.jwtService.HashToken(refreshToken)
        csrfTokenHash := s.jwtService.HashToken(csrfToken)

        newRawRefreshToken, newRefreshTokenHash, err := s.jwtService.GenerateStateToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to generate new refresh token")
        }</span>

        <span class="cov8" title="1">newRawCsrfToken, newCsrfTokenHash, err := s.jwtService.GenerateStateToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to generate new CSRF token")
        }</span>

        <span class="cov8" title="1">var user sqlc.User
        // Track compromise to execute revocation outside the transaction
        var compromisedUserID uint64

        err = s.repo.WithTransaction(ctx, func(q *sqlc.Queries) error </span><span class="cov8" title="1">{
                var err error
                token, err := q.ValidateRefreshToken(ctx, sqlc.ValidateRefreshTokenParams{
                        TokenHash: refreshTokenHash,
                        CsrfHash:  csrfTokenHash,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return apperrors.New(apperrors.ErrCodeUnauthorized, "Invalid or expired refresh token")
                }</span>

                // NEW: Check if token was already revoked - indicates reuse attack
                <span class="cov8" title="1">if token.RevokedAt.Valid </span><span class="cov8" title="1">{
                        s.logger.Error(ctx, "Revoked token reuse detected - potential compromise",
                                s.logger.Field("user_id", token.UserID),
                                s.logger.Field("revoked_at", token.RevokedAt.Time),
                        )

                        // Immediately revoke ALL tokens for this user (compromised account)
                        compromisedUserID = token.UserID

                        return apperrors.New(apperrors.ErrCodeUnauthorized,
                                "Security violation detected. All sessions have been terminated. Please login again.")
                }</span>

                <span class="cov8" title="1">s.metrics.CSRFValidations.WithLabelValues("success").Inc()

                // Validate session binding if enabled
                if s.cfg.Security.SessionBindingEnabled </span><span class="cov8" title="1">{
                        // Only enforce binding if the token has binding data (grace period for old tokens)
                        if token.ClientIp.Valid || token.UserAgent.Valid </span><span class="cov8" title="1">{
                                bindingMismatch := false
                                var mismatchReason string
                                if token.ClientIp.Valid &amp;&amp; token.ClientIp.String != loginCtx.ClientIP </span><span class="cov8" title="1">{
                                        bindingMismatch = true
                                        mismatchReason = "client_ip_mismatch"
                                }</span>
                                <span class="cov8" title="1">if token.UserAgent.Valid &amp;&amp; token.UserAgent.String != loginCtx.UserAgent </span><span class="cov0" title="0">{
                                        bindingMismatch = true
                                        if mismatchReason != "" </span><span class="cov0" title="0">{
                                                mismatchReason = "ip_and_useragent_mismatch"
                                        }</span> else<span class="cov0" title="0"> {
                                                mismatchReason = "user_agent_mismatch"
                                        }</span>
                                }
                                <span class="cov8" title="1">if bindingMismatch </span><span class="cov8" title="1">{
                                        // Log security event
                                        s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                                                Type:      "auth",
                                                Action:    "refresh_token_binding_failed",
                                                UserID:    token.UserID,
                                                Resource:  "session",
                                                Success:   false,
                                                IPAddress: loginCtx.ClientIP,
                                        })
                                        s.metrics.AuthenticationFailures.WithLabelValues("refresh", mismatchReason).Inc()
                                        // Potential session hijacking: revoke all tokens for this user for safety
                                        compromisedUserID = token.UserID
                                        return apperrors.New(apperrors.ErrCodeUnauthorized, "Session validation failed. Please login again")
                                }</span>
                        }
                }

                <span class="cov8" title="1">if err := q.RevokeRefreshToken(ctx, refreshTokenHash); err != nil </span><span class="cov0" title="0">{
                        return apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to revoke old token")
                }</span>

                <span class="cov8" title="1">user, err = q.GetUserByID(ctx, token.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to fetch user")
                }</span>

                <span class="cov8" title="1">if err := q.CreateRefreshToken(ctx, sqlc.CreateRefreshTokenParams{
                        UserID:    user.ID,
                        TokenHash: newRefreshTokenHash,
                        CsrfHash:  newCsrfTokenHash,
                        ClientIp: sql.NullString{
                                String: loginCtx.ClientIP,
                                Valid:  s.cfg.Security.SessionBindingEnabled &amp;&amp; loginCtx.ClientIP != "",
                        },
                        UserAgent: sql.NullString{
                                String: loginCtx.UserAgent,
                                Valid:  s.cfg.Security.SessionBindingEnabled &amp;&amp; loginCtx.UserAgent != "",
                        },
                        ExpiresAt: time.Now().Add(s.jwtService.GetRefreshExpiry()),
                }); err != nil </span><span class="cov0" title="0">{
                        return apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to store new refresh token")
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if compromisedUserID &gt; 0 </span><span class="cov8" title="1">{
                _ = s.queries.RevokeAllUserRefreshTokens(ctx, compromisedUserID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                s.metrics.TokenRefreshes.WithLabelValues("failed").Inc()
                return "", "", "", nil, err
        }</span>

        <span class="cov8" title="1">accessToken, err := s.jwtService.GenerateAccessToken(ctx, user.ID, user.Email, user.Role)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to generate access token")
        }</span>

        <span class="cov8" title="1">s.metrics.TokenRefreshes.WithLabelValues("success").Inc()
        return accessToken, newRawRefreshToken, newRawCsrfToken, &amp;user, nil</span>
}

func (s *Service) Logout(ctx context.Context, refreshToken string) error <span class="cov8" title="1">{
        refreshTokenHash := s.jwtService.HashToken(refreshToken)
        return s.queries.RevokeRefreshToken(ctx, refreshTokenHash)
}</span>

type LockoutInfo struct {
        IsLocked          bool
        FailedAttempts    int
        RetryAfterSeconds int
        LockoutUntil      time.Time
}

func (s *Service) checkAccountLockout(ctx context.Context, email string) (LockoutInfo, error) <span class="cov8" title="1">{
        window := int(s.cfg.Security.LoginLockoutDuration.Minutes())
        attempts, err := s.queries.GetFailedLoginAttempts(ctx, sqlc.GetFailedLoginAttemptsParams{
                Email:   email,
                DATESUB: int32(window),
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return LockoutInfo{}, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to check login attempts")
        }</span>

        <span class="cov8" title="1">failedCount := len(attempts)
        if failedCount &lt; s.cfg.Security.MaxLoginAttempts </span><span class="cov8" title="1">{
                return LockoutInfo{
                        IsLocked:       false,
                        FailedAttempts: failedCount,
                }, nil
        }</span>

        // Calculate exponential backoff using bitwise shifting
        <span class="cov8" title="1">lockoutMultiplier := 0
        if diff := failedCount - s.cfg.Security.MaxLoginAttempts; diff &gt;= 0 </span><span class="cov8" title="1">{
                // 1 &lt;&lt; 6 = 64, which is the first power of 2 exceeding the cap of 60.
                // We cap the shift at 6 to prevent potential overflow on very high failedCounts.
                shift := diff
                if shift &gt; 6 </span><span class="cov8" title="1">{
                        shift = 6
                }</span>
                <span class="cov8" title="1">lockoutMultiplier = min(1&lt;&lt;shift, 60)</span>
        }

        <span class="cov8" title="1">baseLockoutSeconds := int(s.cfg.Security.LoginLockoutDuration.Seconds())
        lockoutDuration := time.Duration(baseLockoutSeconds*lockoutMultiplier) * time.Second

        if len(attempts) &gt; 0 </span><span class="cov8" title="1">{
                lastAttempt := attempts[0].AttemptTime
                lockoutUntil := lastAttempt.Add(lockoutDuration)
                if time.Now().Before(lockoutUntil) </span><span class="cov8" title="1">{
                        retryAfter := int(time.Until(lockoutUntil).Seconds())
                        return LockoutInfo{
                                IsLocked:          true,
                                FailedAttempts:    failedCount,
                                RetryAfterSeconds: retryAfter,
                                LockoutUntil:      lockoutUntil,
                        }, nil
                }</span>
        }

        <span class="cov8" title="1">return LockoutInfo{
                IsLocked:       false,
                FailedAttempts: failedCount,
        }, nil</span>
}

func (s *Service) recordFailedLogin(ctx context.Context, userID uint64, email, ipAddress string) <span class="cov8" title="1">{
        var nullableUserID sql.NullInt64
        if userID &gt; 0 </span><span class="cov8" title="1">{
                nullableUserID = sql.NullInt64{Int64: int64(userID), Valid: true}
        }</span>

        <span class="cov8" title="1">err := s.queries.RecordFailedLoginAttempt(ctx, sqlc.RecordFailedLoginAttemptParams{
                UserID:    nullableUserID,
                Email:     email,
                IpAddress: ipAddress,
        })
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the login flow
                s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                        Type:      "auth",
                        Action:    "failed_login_recording_failed",
                        UserID:    userID,
                        Resource:  "login",
                        Success:   false,
                        IPAddress: ipAddress,
                })
        }</span>
}

// Background job to cleanup old failed login attempts
func (s *Service) CleanupOldFailedLogins(ctx context.Context) error <span class="cov8" title="1">{
        _, err := s.queries.CleanupOldFailedLoginAttempts(ctx, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to cleanup old failed login attempts")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package auth

import (
        "testing"
        "time"

        "github.com/DATA-DOG/go-sqlmock"
        "github.com/stretchr/testify/require"
        "github.com/waqasmani/go-boilerplate/internal/config"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/security"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/sqlc"
        "github.com/waqasmani/go-boilerplate/internal/shared/validator"
)

// authDependencies holds all the mocked and real dependencies
type authDependencies struct {
        mockDB      sqlmock.Sqlmock
        service     *Service
        cfg         *config.Config
        jwtService  *security.JWTService
        passService *security.PasswordService
}

// Helper to create a complete user row that matches sqlc expectations (9 columns)
func mockUserRow(id uint64, email, passwordHash, role string) *sqlmock.Rows <span class="cov8" title="1">{
        return sqlmock.NewRows([]string{
                "id", "email", "password_hash", "first_name", "last_name",
                "role", "is_active", "created_at", "updated_at",
        }).AddRow(
                id, email, passwordHash, "Test", "User",
                role, true, time.Now(), time.Now(),
        )
}</span>

func setupAuthTest(t *testing.T) (*authDependencies, func()) <span class="cov8" title="1">{
        // 1. Setup SQL Mock
        db, mock, err := sqlmock.New()
        require.NoError(t, err)

        // 2. Real Config
        cfg := &amp;config.Config{
                Server: config.ServerConfig{Env: "test"},
                JWT: config.JWTConfig{
                        AccessSecret:  "test_secret_key_must_be_32_bytes_long",
                        AccessExpiry:  15 * time.Minute,
                        RefreshExpiry: 24 * time.Hour,
                },
                Security: config.SecurityConfig{
                        BcryptCost:            4,
                        MaxLoginAttempts:      3,
                        LoginLockoutDuration:  15 * time.Minute,
                        SessionBindingEnabled: true,
                },
        }

        // 3. Services
        jwtService := security.NewJWTService(&amp;cfg.JWT)
        passService := security.NewPasswordService(cfg.Security.BcryptCost)
        validatorInstance := validator.New()

        // 4. Observability
        logger, _ := observability.NewLogger("info", "console")
        auditLogger := observability.NewAuditLogger(logger)
        metrics := observability.NewMetrics()

        // 5. Repositories
        queries := sqlc.New(db)
        repo := sqlc.NewRepository(db)

        service := NewService(
                queries,
                repo,
                jwtService,
                passService,
                validatorInstance,
                auditLogger,
                metrics,
                cfg,
                logger,
        )

        deps := &amp;authDependencies{
                mockDB:      mock,
                service:     service,
                cfg:         cfg,
                jwtService:  jwtService,
                passService: passService,
        }

        return deps, func() </span><span class="cov8" title="1">{ db.Close() }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package health

import (
        "context"
        "database/sql"
        "net/http"
        "runtime"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/redis/go-redis/v9"
        "github.com/waqasmani/go-boilerplate/internal/shared/utils"
)

type Handler struct {
        db           *sql.DB
        startTime    time.Time
        redisEnabled bool
        redisClient  func() (*redis.Client, error)
}

func NewHandler(db *sql.DB, redisEnabled bool) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                db:           db,
                startTime:    time.Now(),
                redisEnabled: redisEnabled,
        }
}</span>

func (h *Handler) SetRedisClientProvider(provider func() (*redis.Client, error)) <span class="cov0" title="0">{
        h.redisClient = provider
}</span>

type HealthResponse struct {
        Status   string         `json:"status"`
        Version  string         `json:"version"`
        Uptime   string         `json:"uptime"`
        Database DatabaseHealth `json:"database"`
        Redis    *RedisHealth   `json:"redis,omitempty"`
        System   SystemHealth   `json:"system"`
}

type DatabaseHealth struct {
        Status          string `json:"status"`
        OpenConnections int    `json:"open_connections"`
        InUse           int    `json:"in_use"`
        Idle            int    `json:"idle"`
        MaxOpenConns    int    `json:"max_open_conns"`
}

type RedisHealth struct {
        Status  string `json:"status"`
        Latency string `json:"latency"`
}

type SystemHealth struct {
        NumGoroutine int    `json:"num_goroutine"`
        MemAllocMB   uint64 `json:"mem_alloc_mb"`
        NumCPU       int    `json:"num_cpu"`
}

// Health godoc
// @Summary Get health status
// @Description Get comprehensive health status of the application
// @Tags Health
// @Accept json
// @Produce json
// @Success 200 {object} HealthResponse
// @Router /health [get]
func (h *Handler) Health(c *gin.Context) <span class="cov0" title="0">{
        dbHealth := h.getDatabaseHealth(c.Request.Context())
        systemHealth := h.getSystemHealth()
        overallStatus := "ok"
        if dbHealth.Status != "ok" </span><span class="cov0" title="0">{
                overallStatus = "degraded"
        }</span>

        <span class="cov0" title="0">response := HealthResponse{
                Status:   overallStatus,
                Version:  "1.0.0",
                Uptime:   time.Since(h.startTime).String(),
                Database: dbHealth,
                System:   systemHealth,
        }

        if h.redisEnabled &amp;&amp; h.redisClient != nil </span><span class="cov0" title="0">{
                redisHealth := h.getRedisHealth(c.Request.Context())
                response.Redis = &amp;redisHealth
                if redisHealth.Status != "ok" &amp;&amp; overallStatus == "ok" </span><span class="cov0" title="0">{
                        overallStatus = "degraded"
                }</span>
                <span class="cov0" title="0">response.Status = overallStatus</span>
        }

        <span class="cov0" title="0">utils.Success(c, http.StatusOK, response)</span>
}

func (h *Handler) getRedisHealth(ctx context.Context) RedisHealth <span class="cov0" title="0">{
        if h.redisClient == nil </span><span class="cov0" title="0">{
                return RedisHealth{Status: "disabled"}
        }</span>

        <span class="cov0" title="0">client, err := h.redisClient()
        if err != nil </span><span class="cov0" title="0">{
                return RedisHealth{Status: "error", Latency: err.Error()}
        }</span>

        <span class="cov0" title="0">start := time.Now()
        pingCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
        defer cancel()
        if err := client.Ping(pingCtx).Err(); err != nil </span><span class="cov0" title="0">{
                return RedisHealth{Status: "error", Latency: err.Error()}
        }</span>
        <span class="cov0" title="0">latency := time.Since(start).String()
        return RedisHealth{Status: "ok", Latency: latency}</span>
}

// Ready godoc
// @Summary Get readiness status
// @Description Check if application is ready to serve traffic
// @Tags Health
// @Accept json
// @Produce json
// @Success 200 {object} HealthResponse
// @Failure 503 {object} HealthResponse
// @Router /ready [get]
func (h *Handler) Ready(c *gin.Context) <span class="cov0" title="0">{
        dbStatus := h.checkDatabase(c.Request.Context())
        if dbStatus != "ok" </span><span class="cov0" title="0">{
                utils.Success(c, http.StatusServiceUnavailable, HealthResponse{
                        Status: "not ready",
                        Database: DatabaseHealth{
                                Status: dbStatus,
                        },
                })
                return
        }</span>
        <span class="cov0" title="0">utils.Success(c, http.StatusOK, HealthResponse{
                Status: "ready",
                Database: DatabaseHealth{
                        Status: "ok",
                },
        })</span>
}

// Alive godoc
// @Summary Get liveness status
// @Description Check if application is alive
// @Tags Health
// @Accept json
// @Produce json
// @Success 200 {object} map[string]string
// @Router /alive [get]
func (h *Handler) Alive(c *gin.Context) <span class="cov0" title="0">{
        utils.Success(c, http.StatusOK, gin.H{
                "status": "alive",
        })
}</span>

func (h *Handler) checkDatabase(ctx context.Context) string <span class="cov0" title="0">{
        dbCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
        defer cancel()
        if err := h.db.PingContext(dbCtx); err != nil </span><span class="cov0" title="0">{
                return "error"
        }</span>
        <span class="cov0" title="0">return "ok"</span>
}

func (h *Handler) getDatabaseHealth(ctx context.Context) DatabaseHealth <span class="cov0" title="0">{
        status := h.checkDatabase(ctx)
        stats := h.db.Stats()
        return DatabaseHealth{
                Status:          status,
                OpenConnections: stats.OpenConnections,
                InUse:           stats.InUse,
                Idle:            stats.Idle,
                MaxOpenConns:    stats.MaxOpenConnections,
        }
}</span>

func (h *Handler) getSystemHealth() SystemHealth <span class="cov0" title="0">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        return SystemHealth{
                NumGoroutine: runtime.NumGoroutine(),
                MemAllocMB:   m.Alloc / 1024 / 1024,
                NumCPU:       runtime.NumCPU(),
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package health

import (
        "github.com/gin-gonic/gin"
        "github.com/redis/go-redis/v9"
)

func RegisterRoutes(router *gin.Engine, handler *Handler) <span class="cov0" title="0">{
        // Set Redis client provider if available
        if handler.redisEnabled </span><span class="cov0" title="0">{
                // This will be set by the container after initialization
                handler.SetRedisClientProvider(func() (*redis.Client, error) </span><span class="cov0" title="0">{
                        // This is a placeholder - actual implementation will be provided by container
                        return nil, nil
                }</span>)
        }

        <span class="cov0" title="0">healthGroup := router.Group("/api/v1")
        healthGroup.GET("/health", handler.Health)
        healthGroup.GET("/ready", handler.Ready)
        healthGroup.GET("/alive", handler.Alive)</span>
}</pre>
		
		<pre class="file" id="file33" style="display: none">package users

import (
        "database/sql"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/sqlc"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
        "github.com/waqasmani/go-boilerplate/internal/shared/utils"
        "github.com/waqasmani/go-boilerplate/internal/shared/validator"
)

type Handler struct {
        service *Service
}

func NewHandler(service *Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{service: service}
}</span>

type UserResponse struct {
        ID        uint64    `json:"id"`
        Email     string    `json:"email"`
        FirstName string    `json:"first_name"`
        LastName  string    `json:"last_name"`
        Role      string    `json:"role"`
        IsActive  bool      `json:"is_active"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

type UpdateUserRequest struct {
        FirstName string `json:"first_name" validate:"required"`
        LastName  string `json:"last_name" validate:"required"`
}

type UpdatePasswordRequest struct {
        OldPassword string `json:"old_password" validate:"required"`
        NewPassword string `json:"new_password" validate:"required,min=8"`
}

type CreateUserRequest struct {
        Email     string `json:"email" validate:"required,email"`
        Password  string `json:"password" validate:"required,min=8"`
        FirstName string `json:"first_name" validate:"required"`
        LastName  string `json:"last_name" validate:"required"`
        Role      string `json:"role" validate:"required,oneof=user admin"`
}

type ListUsersResponse struct {
        Users []UserResponse `json:"users"`
        Total int64          `json:"total"`
        Limit int            `json:"limit"`
        Page  int            `json:"page"`
}

// GetUser godoc
// @Summary Get user by ID
// @Description Get user details by ID
// @Tags Users
// @Accept json
// @Produce json
// @Param id path int true "User ID"
// @Success 200 {object} utils.Response{data=UserResponse}
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /users/{id} [get]
func (h *Handler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        userID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid user ID"))
                return
        }</span>

        // CRITICAL: Check authorization before fetching data
        <span class="cov0" title="0">if err := middleware.IsAdminOrOwner(c, userID); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.service.queries.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        utils.Error(c, errors.ErrNotFound)
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(c, errors.Wrap(err, errors.ErrCodeInternal, "Failed to fetch user"))
                return</span>
        }

        <span class="cov0" title="0">utils.Success(c, http.StatusOK, UserResponse{
                ID:        user.ID,
                Email:     user.Email,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                Role:      user.Role,
                IsActive:  user.IsActive,
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
        })</span>
}

// UpdateUser godoc
// @Summary Update user profile
// @Description Update user's first and last name
// @Tags Users
// @Accept json
// @Produce json
// @Param id path int true "User ID"
// @Param body body UpdateUserRequest true "Updated user details"
// @Success 200 {object} utils.Response{data=UserResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /users/{id} [put]
func (h *Handler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        userID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid user ID"))
                return
        }</span>

        // CRITICAL: Check authorization before processing update
        <span class="cov0" title="0">if err := middleware.IsAdminOrOwner(c, userID); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.UpdateUser(c.Request.Context(), userID, req.FirstName, req.LastName); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>
        <span class="cov0" title="0">user, err := h.service.queries.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeInternal, "Failed to fetch updated user"))
                return
        }</span>

        <span class="cov0" title="0">utils.Success(c, http.StatusOK, UserResponse{
                ID:        user.ID,
                Email:     user.Email,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                Role:      user.Role,
                IsActive:  user.IsActive,
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
        })</span>
}

// UpdatePassword godoc
// @Summary Update user password
// @Description Change user's password
// @Tags Users
// @Accept json
// @Produce json
// @Param id path int true "User ID"
// @Param body body UpdatePasswordRequest true "Password update details"
// @Success 200 {object} utils.Response{data=map[string]string}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /users/{id}/password [put]
func (h *Handler) UpdatePassword(c *gin.Context) <span class="cov0" title="0">{
        userID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid user ID"))
                return
        }</span>

        // CRITICAL: Strict ownership check - even admins cannot change other users' passwords
        <span class="cov0" title="0">if err := middleware.RequireOwnership(c, userID); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov0" title="0">var req UpdatePasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.UpdatePassword(c.Request.Context(), userID, req.OldPassword, req.NewPassword); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov0" title="0">utils.Success(c, http.StatusOK, gin.H{"message": "Password updated successfully"})</span>
}

// ListUsers godoc
// @Summary List users
// @Description Get paginated list of users (admin only)
// @Tags Users
// @Accept json
// @Produce json
// @Param limit query int false "Page size" default(20) minimum(1) maximum(100)
// @Param page query int false "Page number" default(1) minimum(1)
// @Success 200 {object} utils.Response{data=ListUsersResponse}
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Security     Bearer
// @Router /users [get]
func (h *Handler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))

        // Validate pagination limits
        if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100 // Enforce max limit
        }</span>
        <span class="cov0" title="0">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * limit

        users, err := h.service.queries.ListUsers(c.Request.Context(), sqlc.ListUsersParams{
                Limit:  int32(limit),
                Offset: int32(offset),
        })
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeInternal, "Failed to fetch users"))
                return
        }</span>

        <span class="cov0" title="0">total, err := h.service.queries.CountUsers(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeInternal, "Failed to count users"))
                return
        }</span>

        <span class="cov0" title="0">userResponses := make([]UserResponse, len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                userResponses[i] = UserResponse{
                        ID:        user.ID,
                        Email:     user.Email,
                        FirstName: user.FirstName,
                        LastName:  user.LastName,
                        Role:      user.Role,
                        IsActive:  user.IsActive,
                        CreatedAt: user.CreatedAt,
                        UpdatedAt: user.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">utils.Success(c, http.StatusOK, ListUsersResponse{
                Users: userResponses,
                Total: total,
                Limit: limit,
                Page:  page,
        })</span>
}

// CreateUser godoc
// @Summary Create user
// @Description Create a new user (admin only)
// @Tags Users
// @Accept json
// @Produce json
// @Param body body CreateUserRequest true "User creation details"
// @Success 201 {object} utils.Response{data=UserResponse}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Failure 409 {object} utils.Response
// @Security     Bearer
// @Router /users [post]
func (h *Handler) CreateUser(c *gin.Context) <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.Wrap(err, errors.ErrCodeBadRequest, "Invalid request body"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                validationErrors := validator.TranslateValidationErrors(err)
                utils.Error(c, errors.WithDetails(errors.ErrCodeValidation, "Validation failed", validationErrors))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.service.CreateUser(c.Request.Context(), req.Email, req.Password, req.FirstName, req.LastName, req.Role)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov0" title="0">utils.Success(c, http.StatusCreated, UserResponse{
                ID:        user.ID,
                Email:     user.Email,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                Role:      user.Role,
                IsActive:  user.IsActive,
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
        })</span>
}

// DeleteUser godoc
// @Summary Delete user
// @Description Soft delete a user (admin only)
// @Tags Users
// @Accept json
// @Produce json
// @Param id path int true "User ID"
// @Success 204
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 403 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Security     Bearer
// @Router /users/{id} [delete]
func (h *Handler) DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        userID, err := strconv.ParseUint(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Invalid user ID"))
                return
        }</span>

        // CRITICAL: Prevent admins from deleting their own account
        <span class="cov0" title="0">authUserID, err := middleware.GetCurrentUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov0" title="0">if authUserID == userID </span><span class="cov0" title="0">{
                utils.Error(c, errors.New(errors.ErrCodeBadRequest, "Cannot delete your own account"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.DeleteUser(c.Request.Context(), userID); err != nil </span><span class="cov0" title="0">{
                utils.Error(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package users

import (
        "github.com/gin-gonic/gin"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/middleware"
)

func RegisterRoutes(router *gin.Engine, handler *Handler, authMiddleware *middleware.AuthMiddleware) <span class="cov0" title="0">{
        usersGroup := router.Group("/api/v1/users")
        usersGroup.Use(authMiddleware.Authenticate())
        </span><span class="cov0" title="0">{
                usersGroup.GET("/:id", handler.GetUser)
                usersGroup.PUT("/:id", handler.UpdateUser)
                usersGroup.PUT("/:id/password", handler.UpdatePassword)

                // Admin-only routes
                adminGroup := usersGroup.Group("")
                adminGroup.Use(authMiddleware.Authorize("admin"))
                </span><span class="cov0" title="0">{
                        adminGroup.GET("", handler.ListUsers)
                        adminGroup.POST("", handler.CreateUser)
                        adminGroup.DELETE("/:id", handler.DeleteUser)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file35" style="display: none">package users

import (
        "context"
        "database/sql"
        "log"
        "time"

        dberrors "github.com/waqasmani/go-boilerplate/internal/infrastructure/database/errors"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/security"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/sqlc"
        apperrors "github.com/waqasmani/go-boilerplate/internal/shared/errors"
        "github.com/waqasmani/go-boilerplate/internal/shared/validator"
)

type Service struct {
        queries         *sqlc.Queries
        repo            *sqlc.Repository
        passwordService *security.PasswordService
        validator       *validator.Validator
        auditLogger     *observability.AuditLogger
        logger          *observability.Logger
}

func NewService(
        queries *sqlc.Queries,
        repo *sqlc.Repository,
        passwordService *security.PasswordService,
        validator *validator.Validator,
        auditLogger *observability.AuditLogger,
        logger *observability.Logger,
) *Service <span class="cov0" title="0">{
        return &amp;Service{
                queries:         queries,
                repo:            repo,
                passwordService: passwordService,
                validator:       validator,
                auditLogger:     auditLogger,
                logger:          logger,
        }
}</span>

func (s *Service) UpdateUser(ctx context.Context, userID uint64, firstName, lastName string) error <span class="cov0" title="0">{
        // Wrap the update in a retryable transaction
        return dberrors.RetryOperation(ctx, "update_user", func(attempt uint64) error </span><span class="cov0" title="0">{
                start := time.Now()
                defer func() </span><span class="cov0" title="0">{
                        duration := time.Since(start)
                        if duration &gt; 100*time.Millisecond </span><span class="cov0" title="0">{
                                // Log slow queries
                                if s.logger != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn(ctx, "Slow database operation",
                                                s.logger.Field("operation", "update_user"),
                                                s.logger.Field("duration_ms", int64(duration.Milliseconds())),
                                                s.logger.Field("attempt", int64(attempt)),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("Slow database operation: update_user took %dms on attempt %d", duration.Milliseconds(), attempt)
                                }</span>
                        }
                }()

                <span class="cov0" title="0">err := s.queries.UpdateUser(ctx, sqlc.UpdateUserParams{
                        ID:        userID,
                        FirstName: firstName,
                        LastName:  lastName,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, dberrors.DefaultRetryConfig(), nil, nil)
}

func (s *Service) UpdatePassword(ctx context.Context, userID uint64, oldPassword, newPassword string) error <span class="cov0" title="0">{
        user, err := s.queries.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return apperrors.ErrNotFound
                }</span>
                <span class="cov0" title="0">return apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to fetch user")</span>
        }

        <span class="cov0" title="0">if err := s.passwordService.Compare(ctx, user.PasswordHash, oldPassword); err != nil </span><span class="cov0" title="0">{
                s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                        Type:     "user",
                        Action:   "password_change_failed",
                        UserID:   userID,
                        Resource: "user",
                        Success:  false,
                })
                return apperrors.New(apperrors.ErrCodeUnauthorized, "Current password is incorrect")
        }</span>

        <span class="cov0" title="0">newPasswordHash, err := s.passwordService.Hash(ctx, newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.Wrap(err, apperrors.ErrCodeValidation, "Invalid password")
        }</span>

        <span class="cov0" title="0">err = s.repo.WithTransaction(ctx, func(q *sqlc.Queries) error </span><span class="cov0" title="0">{
                // Update the password
                err := q.UpdateUserPassword(ctx, sqlc.UpdateUserPasswordParams{
                        ID:           userID,
                        PasswordHash: newPasswordHash,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // REFACTORED: Revoke all active sessions for this user
                // This prevents an attacker with a stolen refresh token from remaining logged in.
                <span class="cov0" title="0">return q.RevokeAllUserRefreshTokens(ctx, userID)</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to update password")
        }</span>

        <span class="cov0" title="0">s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                Type:     "user",
                Action:   "password_change",
                UserID:   userID,
                Resource: "user",
                Success:  true,
        })

        return nil</span>
}

func (s *Service) CreateUser(ctx context.Context, email, password, firstName, lastName, role string) (*sqlc.User, error) <span class="cov0" title="0">{
        existingUser, err := s.queries.GetUserByEmail(ctx, email)
        if err == nil &amp;&amp; existingUser.ID &gt; 0 </span><span class="cov0" title="0">{
                return nil, apperrors.New(apperrors.ErrCodeConflict, "Email already registered")
        }</span>

        <span class="cov0" title="0">if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to check existing user")
        }</span>

        <span class="cov0" title="0">passwordHash, err := s.passwordService.Hash(ctx, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeValidation, "Invalid password")
        }</span>

        <span class="cov0" title="0">result, err := s.queries.CreateUser(ctx, sqlc.CreateUserParams{
                Email:        email,
                PasswordHash: passwordHash,
                FirstName:    firstName,
                LastName:     lastName,
                Role:         role,
                IsActive:     true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to create user")
        }</span>

        <span class="cov0" title="0">userID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to get user ID")
        }</span>

        <span class="cov0" title="0">user, err := s.queries.GetUserByID(ctx, uint64(userID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to fetch created user")
        }</span>

        <span class="cov0" title="0">s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                Type:     "user",
                Action:   "create",
                UserID:   user.ID,
                Resource: "user",
                Success:  true,
        })

        return &amp;user, nil</span>
}

func (s *Service) DeleteUser(ctx context.Context, userID uint64) error <span class="cov0" title="0">{
        _, err := s.queries.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return apperrors.ErrNotFound
                }</span>
                <span class="cov0" title="0">return apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to fetch user")</span>
        }

        <span class="cov0" title="0">err = s.queries.DeactivateUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.Wrap(err, apperrors.ErrCodeInternal, "Failed to delete user")
        }</span>

        <span class="cov0" title="0">s.auditLogger.LogSecurityEvent(ctx, observability.SecurityEvent{
                Type:     "user",
                Action:   "delete",
                UserID:   userID,
                Resource: "user",
                Success:  true,
        })

        return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package errors

import (
        "errors"
        "fmt"
)

type ErrorCode string
type ErrorType string

const (
        // Error Types
        ErrorTypeClient  ErrorType = "client_error"
        ErrorTypeServer  ErrorType = "server_error"
        ErrorTypeNetwork ErrorType = "network_error"

        // Error Codes
        ErrCodeInternal           ErrorCode = "INTERNAL_ERROR"
        ErrCodeNotFound           ErrorCode = "NOT_FOUND"
        ErrCodeBadRequest         ErrorCode = "BAD_REQUEST"
        ErrCodeUnauthorized       ErrorCode = "UNAUTHORIZED"
        ErrCodeForbidden          ErrorCode = "FORBIDDEN"
        ErrCodeConflict           ErrorCode = "CONFLICT"
        ErrCodeValidation         ErrorCode = "VALIDATION_ERROR"
        ErrCodeInvalidToken       ErrorCode = "INVALID_TOKEN"
        ErrCodeExpiredToken       ErrorCode = "EXPIRED_TOKEN"
        ErrCodeRevokedToken       ErrorCode = "REVOKED_TOKEN"
        ErrCodeInvalidCredentials ErrorCode = "INVALID_CREDENTIALS"
        ErrCodeTooManyRequests    ErrorCode = "TOO_MANY_REQUESTS"
        ErrCodeTimeout            ErrorCode = "TIMEOUT"
        ErrCodeDatabaseError      ErrorCode = "DATABASE_ERROR"
        ErrCodeServiceUnavailable ErrorCode = "SERVICE_UNAVAILABLE"
        ErrInvalidStatus          ErrorCode = "INVALID_STATUS"
)

type AppError struct {
        Code       ErrorCode
        Message    string
        Details    any
        Err        error
        ErrorType  ErrorType
        StatusCode int
        Retryable  bool
        Version    string
}

func (e *AppError) Error() string <span class="cov8" title="1">{
        if e.Err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %s (%v)", e.Code, e.Message, e.Err)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

func (e *AppError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

func (e *AppError) Is(target error) bool <span class="cov0" title="0">{
        t, ok := target.(*AppError)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return e.Code == t.Code</span>
}

func (e *AppError) GetErrorType() ErrorType <span class="cov0" title="0">{
        return e.ErrorType
}</span>

func determineErrorType(code ErrorCode) ErrorType <span class="cov8" title="1">{
        switch code </span>{
        case ErrCodeBadRequest, ErrCodeUnauthorized, ErrCodeForbidden,
                ErrCodeNotFound, ErrCodeInvalidToken, ErrCodeExpiredToken,
                ErrCodeValidation, ErrCodeInvalidCredentials, ErrCodeTooManyRequests:<span class="cov8" title="1">
                return ErrorTypeClient</span>
        case ErrCodeServiceUnavailable, ErrCodeTimeout:<span class="cov8" title="1">
                return ErrorTypeNetwork</span>
        default:<span class="cov8" title="1">
                return ErrorTypeServer</span>
        }
}

func New(code ErrorCode, message string) *AppError <span class="cov8" title="1">{
        return &amp;AppError{
                Code:      code,
                Message:   message,
                ErrorType: determineErrorType(code),
                Version:   "v1",
        }
}</span>

func Wrap(err error, code ErrorCode, message string) *AppError <span class="cov8" title="1">{
        return &amp;AppError{
                Code:      code,
                Message:   message,
                Err:       err,
                ErrorType: determineErrorType(code),
                Version:   "v1",
        }
}</span>

func WithDetails(code ErrorCode, message string, details interface{}) *AppError <span class="cov8" title="1">{
        return &amp;AppError{
                Code:      code,
                Message:   message,
                Details:   details,
                ErrorType: determineErrorType(code),
                Version:   "v1",
        }
}</span>

func AsAppError(err error) (*AppError, bool) <span class="cov0" title="0">{
        var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                return appErr, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

var (
        ErrInternal           = New(ErrCodeInternal, "Internal server error")
        ErrNotFound           = New(ErrCodeNotFound, "Resource not found")
        ErrBadRequest         = New(ErrCodeBadRequest, "Bad request")
        ErrUnauthorized       = New(ErrCodeUnauthorized, "Unauthorized")
        ErrForbidden          = New(ErrCodeForbidden, "Forbidden")
        ErrConflict           = New(ErrCodeConflict, "Resource already exists")
        ErrInvalidCredentials = New(ErrCodeInvalidCredentials, "Invalid credentials")
        ErrInvalidToken       = New(ErrCodeInvalidToken, "Invalid token")
        ErrExpiredToken       = New(ErrCodeExpiredToken, "Token expired")
        ErrRevokedToken       = New(ErrCodeRevokedToken, "Token revoked")
        ErrTimeout            = New(ErrCodeTimeout, "Request timeout")
        ErrServiceUnavailable = New(ErrCodeServiceUnavailable, "Service unavailable")
)
</pre>
		
		<pre class="file" id="file37" style="display: none">package utils

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/waqasmani/go-boilerplate/internal/infrastructure/observability"
        "github.com/waqasmani/go-boilerplate/internal/shared/errors"
)

type Response struct {
        Success bool           `json:"success"`
        Data    any            `json:"data,omitempty"`
        Error   *ErrorResponse `json:"error,omitempty"`
        Version string         `json:"version"`
}

type ErrorResponse struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details any    `json:"details,omitempty"`
        Type    string `json:"type"`
}

func Success(c *gin.Context, statusCode int, data any) <span class="cov8" title="1">{
        c.JSON(statusCode, Response{
                Success: true,
                Data:    data,
                Version: "v1",
        })
}</span>

func Error(c *gin.Context, err error) <span class="cov8" title="1">{
        appErr, ok := err.(*errors.AppError)
        if !ok </span><span class="cov8" title="1">{
                appErr = errors.Wrap(err, errors.ErrCodeInternal, "An unexpected error occurred")
        }</span>

        // Get correlation IDs from context
        <span class="cov8" title="1">traceID := c.GetString(string(observability.TraceIDKey))
        requestID := c.GetString(string(observability.RequestIDKey))

        // Add correlation IDs to error details
        if appErr.Details == nil </span><span class="cov8" title="1">{
                appErr.Details = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if details, ok := appErr.Details.(map[string]string); ok </span><span class="cov8" title="1">{
                if traceID != "" </span><span class="cov0" title="0">{
                        details["trace_id"] = traceID
                }</span>
                <span class="cov8" title="1">if requestID != "" </span><span class="cov0" title="0">{
                        details["request_id"] = requestID
                }</span>
        }

        <span class="cov8" title="1">statusCode := getHTTPStatusCode(appErr.Code)
        c.JSON(statusCode, Response{
                Success: false,
                Error: &amp;ErrorResponse{
                        Code:    string(appErr.Code),
                        Message: appErr.Message,
                        Details: appErr.Details,
                        Type:    string(appErr.ErrorType),
                },
                Version: "v1",
        })</span>
}

func getHTTPStatusCode(code errors.ErrorCode) int <span class="cov8" title="1">{
        switch code </span>{
        case errors.ErrCodeNotFound:<span class="cov8" title="1">
                return http.StatusNotFound</span>
        case errors.ErrCodeBadRequest, errors.ErrCodeValidation:<span class="cov0" title="0">
                return http.StatusBadRequest</span>
        case errors.ErrCodeUnauthorized, errors.ErrCodeInvalidToken, errors.ErrCodeExpiredToken, errors.ErrCodeRevokedToken, errors.ErrCodeInvalidCredentials:<span class="cov0" title="0">
                return http.StatusUnauthorized</span>
        case errors.ErrCodeForbidden:<span class="cov0" title="0">
                return http.StatusForbidden</span>
        case errors.ErrCodeConflict:<span class="cov0" title="0">
                return http.StatusConflict</span>
        case errors.ErrCodeTooManyRequests:<span class="cov0" title="0">
                return http.StatusTooManyRequests</span>
        case errors.ErrCodeServiceUnavailable:<span class="cov0" title="0">
                return http.StatusServiceUnavailable</span>
        default:<span class="cov8" title="1">
                return http.StatusInternalServerError</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package validator

import (
        "github.com/go-playground/validator/v10"
)

type Validator struct {
        validate *validator.Validate
}

func New() *Validator <span class="cov8" title="1">{
        return &amp;Validator{
                validate: validator.New(),
        }
}</span>

func (v *Validator) Validate(i interface{}) error <span class="cov8" title="1">{
        return v.validate.Struct(i)
}</span>

func (v *Validator) ValidateVar(field interface{}, tag string) error <span class="cov0" title="0">{
        return v.validate.Var(field, tag)
}</span>

type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

func TranslateValidationErrors(err error) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError

        if validationErrs, ok := err.(validator.ValidationErrors); ok </span><span class="cov8" title="1">{
                for _, e := range validationErrs </span><span class="cov8" title="1">{
                        errors = append(errors, ValidationError{
                                Field:   e.Field(),
                                Message: getErrorMessage(e),
                        })
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

func getErrorMessage(e validator.FieldError) string <span class="cov8" title="1">{
        switch e.Tag() </span>{
        case "required":<span class="cov0" title="0">
                return "This field is required"</span>
        case "email":<span class="cov8" title="1">
                return "Invalid email format"</span>
        case "min":<span class="cov0" title="0">
                return "Value is too short"</span>
        case "max":<span class="cov0" title="0">
                return "Value is too long"</span>
        case "gte":<span class="cov8" title="1">
                return "Value must be greater than or equal to " + e.Param()</span>
        case "lte":<span class="cov0" title="0">
                return "Value must be less than or equal to " + e.Param()</span>
        default:<span class="cov0" title="0">
                return "Invalid value"</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

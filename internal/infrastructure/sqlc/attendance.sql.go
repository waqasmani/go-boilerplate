// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attendance.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const acquireLock = `-- name: AcquireLock :exec
SELECT GET_LOCK(?, 10)
`

func (q *Queries) AcquireLock(ctx context.Context, getLOCK string) error {
	_, err := q.db.ExecContext(ctx, acquireLock, getLOCK)
	return err
}

const approveTimeOff = `-- name: ApproveTimeOff :exec
UPDATE time_off_requests
SET status = 'approved', reviewed_by = ?, reviewed_at = NOW(), 
    review_note = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type ApproveTimeOffParams struct {
	ReviewedBy sql.NullInt64  `json:"reviewed_by"`
	ReviewNote sql.NullString `json:"review_note"`
	ID         uint64         `json:"id"`
}

func (q *Queries) ApproveTimeOff(ctx context.Context, arg ApproveTimeOffParams) error {
	_, err := q.db.ExecContext(ctx, approveTimeOff, arg.ReviewedBy, arg.ReviewNote, arg.ID)
	return err
}

const assignShiftToEmployee = `-- name: AssignShiftToEmployee :exec
INSERT INTO employee_shifts (user_id, shift_id, effective_date, end_date)
VALUES (?, ?, ?, ?)
`

type AssignShiftToEmployeeParams struct {
	UserID        uint64       `json:"user_id"`
	ShiftID       uint64       `json:"shift_id"`
	EffectiveDate time.Time    `json:"effective_date"`
	EndDate       sql.NullTime `json:"end_date"`
}

func (q *Queries) AssignShiftToEmployee(ctx context.Context, arg AssignShiftToEmployeeParams) error {
	_, err := q.db.ExecContext(ctx, assignShiftToEmployee,
		arg.UserID,
		arg.ShiftID,
		arg.EffectiveDate,
		arg.EndDate,
	)
	return err
}

const autoCloseStaleAttendance = `-- name: AutoCloseStaleAttendance :execresult
UPDATE attendance_records
SET check_out_at = DATE_ADD(check_in_at, INTERVAL 24 HOUR),
    duration_seconds = 86400,
    status = 'manual',
    updated_at = CURRENT_TIMESTAMP
WHERE check_out_at IS NULL
  AND check_in_at < DATE_SUB(NOW(), INTERVAL ? HOUR)
`

func (q *Queries) AutoCloseStaleAttendance(ctx context.Context, dateSUB interface{}) (sql.Result, error) {
	return q.db.ExecContext(ctx, autoCloseStaleAttendance, dateSUB)
}

const closeAttendance = `-- name: CloseAttendance :exec
UPDATE attendance_records
SET check_out_at = ?, duration_seconds = ?, overtime_seconds = ?, 
    check_out_lat = ?, check_out_lng = ?, client_check_out_at = ?,
    is_early_leave = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type CloseAttendanceParams struct {
	CheckOutAt       sql.NullTime   `json:"check_out_at"`
	DurationSeconds  sql.NullInt32  `json:"duration_seconds"`
	OvertimeSeconds  sql.NullInt32  `json:"overtime_seconds"`
	CheckOutLat      sql.NullString `json:"check_out_lat"`
	CheckOutLng      sql.NullString `json:"check_out_lng"`
	ClientCheckOutAt sql.NullTime   `json:"client_check_out_at"`
	IsEarlyLeave     bool           `json:"is_early_leave"`
	ID               uint64         `json:"id"`
}

func (q *Queries) CloseAttendance(ctx context.Context, arg CloseAttendanceParams) error {
	_, err := q.db.ExecContext(ctx, closeAttendance,
		arg.CheckOutAt,
		arg.DurationSeconds,
		arg.OvertimeSeconds,
		arg.CheckOutLat,
		arg.CheckOutLng,
		arg.ClientCheckOutAt,
		arg.IsEarlyLeave,
		arg.ID,
	)
	return err
}

const countAttendance = `-- name: CountAttendance :one
SELECT COUNT(*) FROM attendance_records
WHERE (? = 0 OR user_id = ?)
  AND (? IS NULL OR check_in_at >= ?)
  AND (? IS NULL OR check_in_at <= ?)
  AND (? = '' OR status = ?)
  AND (? = 0 OR shift_id = ?)
`

type CountAttendanceParams struct {
	Column1     interface{}             `json:"column_1"`
	UserID      uint64                  `json:"user_id"`
	Column3     interface{}             `json:"column_3"`
	CheckInAt   time.Time               `json:"check_in_at"`
	Column5     interface{}             `json:"column_5"`
	CheckInAt_2 time.Time               `json:"check_in_at_2"`
	Column7     interface{}             `json:"column_7"`
	Status      AttendanceRecordsStatus `json:"status"`
	Column9     interface{}             `json:"column_9"`
	ShiftID     sql.NullInt64           `json:"shift_id"`
}

func (q *Queries) CountAttendance(ctx context.Context, arg CountAttendanceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAttendance,
		arg.Column1,
		arg.UserID,
		arg.Column3,
		arg.CheckInAt,
		arg.Column5,
		arg.CheckInAt_2,
		arg.Column7,
		arg.Status,
		arg.Column9,
		arg.ShiftID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttendance = `-- name: CreateAttendance :execresult

INSERT INTO attendance_records (
    user_id, shift_id, check_in_at, check_in_lat, check_in_lng, 
    client_check_in_at, is_late, status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateAttendanceParams struct {
	UserID          uint64                  `json:"user_id"`
	ShiftID         sql.NullInt64           `json:"shift_id"`
	CheckInAt       time.Time               `json:"check_in_at"`
	CheckInLat      sql.NullString          `json:"check_in_lat"`
	CheckInLng      sql.NullString          `json:"check_in_lng"`
	ClientCheckInAt sql.NullTime            `json:"client_check_in_at"`
	IsLate          bool                    `json:"is_late"`
	Status          AttendanceRecordsStatus `json:"status"`
}

// Attendance Records Queries
func (q *Queries) CreateAttendance(ctx context.Context, arg CreateAttendanceParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createAttendance,
		arg.UserID,
		arg.ShiftID,
		arg.CheckInAt,
		arg.CheckInLat,
		arg.CheckInLng,
		arg.ClientCheckInAt,
		arg.IsLate,
		arg.Status,
	)
}

const createAttendanceException = `-- name: CreateAttendanceException :exec

INSERT INTO attendance_exceptions (attendance_id, exception_type, severity, auto_flagged)
VALUES (?, ?, ?, ?)
`

type CreateAttendanceExceptionParams struct {
	AttendanceID  uint64                            `json:"attendance_id"`
	ExceptionType AttendanceExceptionsExceptionType `json:"exception_type"`
	Severity      AttendanceExceptionsSeverity      `json:"severity"`
	AutoFlagged   bool                              `json:"auto_flagged"`
}

// Exceptions
func (q *Queries) CreateAttendanceException(ctx context.Context, arg CreateAttendanceExceptionParams) error {
	_, err := q.db.ExecContext(ctx, createAttendanceException,
		arg.AttendanceID,
		arg.ExceptionType,
		arg.Severity,
		arg.AutoFlagged,
	)
	return err
}

const createAttendanceNote = `-- name: CreateAttendanceNote :exec

INSERT INTO attendance_notes (attendance_id, added_by, note)
VALUES (?, ?, ?)
`

type CreateAttendanceNoteParams struct {
	AttendanceID uint64 `json:"attendance_id"`
	AddedBy      uint64 `json:"added_by"`
	Note         string `json:"note"`
}

// Attendance Notes
func (q *Queries) CreateAttendanceNote(ctx context.Context, arg CreateAttendanceNoteParams) error {
	_, err := q.db.ExecContext(ctx, createAttendanceNote, arg.AttendanceID, arg.AddedBy, arg.Note)
	return err
}

const createHoliday = `-- name: CreateHoliday :execresult

INSERT INTO holidays (name, date, is_paid, description)
VALUES (?, ?, ?, ?)
`

type CreateHolidayParams struct {
	Name        string         `json:"name"`
	Date        time.Time      `json:"date"`
	IsPaid      bool           `json:"is_paid"`
	Description sql.NullString `json:"description"`
}

// Holidays
func (q *Queries) CreateHoliday(ctx context.Context, arg CreateHolidayParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createHoliday,
		arg.Name,
		arg.Date,
		arg.IsPaid,
		arg.Description,
	)
}

const createShift = `-- name: CreateShift :execresult

INSERT INTO shifts (name, start_time, end_time, break_minutes, is_active)
VALUES (?, ?, ?, ?, ?)
`

type CreateShiftParams struct {
	Name         string    `json:"name"`
	StartTime    time.Time `json:"start_time"`
	EndTime      time.Time `json:"end_time"`
	BreakMinutes uint32    `json:"break_minutes"`
	IsActive     bool      `json:"is_active"`
}

// Shift Queries
func (q *Queries) CreateShift(ctx context.Context, arg CreateShiftParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createShift,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
		arg.BreakMinutes,
		arg.IsActive,
	)
}

const createTimeOffRequest = `-- name: CreateTimeOffRequest :execresult

INSERT INTO time_off_requests (user_id, leave_type, start_date, end_date, days_count, reason, status)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateTimeOffRequestParams struct {
	UserID    uint64                   `json:"user_id"`
	LeaveType TimeOffRequestsLeaveType `json:"leave_type"`
	StartDate time.Time                `json:"start_date"`
	EndDate   time.Time                `json:"end_date"`
	DaysCount string                   `json:"days_count"`
	Reason    sql.NullString           `json:"reason"`
	Status    TimeOffRequestsStatus    `json:"status"`
}

// Time Off Requests
func (q *Queries) CreateTimeOffRequest(ctx context.Context, arg CreateTimeOffRequestParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTimeOffRequest,
		arg.UserID,
		arg.LeaveType,
		arg.StartDate,
		arg.EndDate,
		arg.DaysCount,
		arg.Reason,
		arg.Status,
	)
}

const dailySummary = `-- name: DailySummary :many

SELECT DATE(check_in_at) as date,
    COUNT(*) as total_attendance,
    SUM(CASE WHEN status = 'present' THEN 1 ELSE 0 END) as present_count,
    SUM(CASE WHEN status = 'on_leave' THEN 1 ELSE 0 END) as on_leave_count,
    SUM(CASE WHEN status = 'absent' THEN 1 ELSE 0 END) as absent_count,
    SUM(CASE WHEN is_late = TRUE THEN 1 ELSE 0 END) as late_count,
    SUM(IFNULL(duration_seconds, 0)) as total_seconds,
    SUM(IFNULL(overtime_seconds, 0)) as total_overtime_seconds
FROM attendance_records
WHERE DATE(check_in_at) = ?
GROUP BY DATE(check_in_at)
`

type DailySummaryRow struct {
	Date                 time.Time   `json:"date"`
	TotalAttendance      int64       `json:"total_attendance"`
	PresentCount         interface{} `json:"present_count"`
	OnLeaveCount         interface{} `json:"on_leave_count"`
	AbsentCount          interface{} `json:"absent_count"`
	LateCount            interface{} `json:"late_count"`
	TotalSeconds         interface{} `json:"total_seconds"`
	TotalOvertimeSeconds interface{} `json:"total_overtime_seconds"`
}

// Reports
func (q *Queries) DailySummary(ctx context.Context, checkInAt time.Time) ([]DailySummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, dailySummary, checkInAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DailySummaryRow{}
	for rows.Next() {
		var i DailySummaryRow
		if err := rows.Scan(
			&i.Date,
			&i.TotalAttendance,
			&i.PresentCount,
			&i.OnLeaveCount,
			&i.AbsentCount,
			&i.LateCount,
			&i.TotalSeconds,
			&i.TotalOvertimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const employeeMonthlyAggregate = `-- name: EmployeeMonthlyAggregate :one
SELECT user_id,
    COUNT(*) as total_days,
    SUM(IFNULL(duration_seconds, 0)) as total_seconds,
    SUM(IFNULL(overtime_seconds, 0)) as total_overtime_seconds,
    SUM(CASE WHEN is_late = TRUE THEN 1 ELSE 0 END) as late_count,
    SUM(CASE WHEN is_early_leave = TRUE THEN 1 ELSE 0 END) as early_leave_count
FROM attendance_records
WHERE user_id = ?
  AND check_in_at >= ?
  AND check_in_at < ?
GROUP BY user_id
`

type EmployeeMonthlyAggregateParams struct {
	UserID      uint64    `json:"user_id"`
	CheckInAt   time.Time `json:"check_in_at"`
	CheckInAt_2 time.Time `json:"check_in_at_2"`
}

type EmployeeMonthlyAggregateRow struct {
	UserID               uint64      `json:"user_id"`
	TotalDays            int64       `json:"total_days"`
	TotalSeconds         interface{} `json:"total_seconds"`
	TotalOvertimeSeconds interface{} `json:"total_overtime_seconds"`
	LateCount            interface{} `json:"late_count"`
	EarlyLeaveCount      interface{} `json:"early_leave_count"`
}

func (q *Queries) EmployeeMonthlyAggregate(ctx context.Context, arg EmployeeMonthlyAggregateParams) (EmployeeMonthlyAggregateRow, error) {
	row := q.db.QueryRowContext(ctx, employeeMonthlyAggregate, arg.UserID, arg.CheckInAt, arg.CheckInAt_2)
	var i EmployeeMonthlyAggregateRow
	err := row.Scan(
		&i.UserID,
		&i.TotalDays,
		&i.TotalSeconds,
		&i.TotalOvertimeSeconds,
		&i.LateCount,
		&i.EarlyLeaveCount,
	)
	return i, err
}

const exportTimesheetForPeriod = `-- name: ExportTimesheetForPeriod :many
SELECT ar.id, ar.user_id, u.email, u.first_name, u.last_name,
    DATE(ar.check_in_at) as work_date,
    ar.check_in_at, ar.check_out_at,
    ar.duration_seconds, ar.overtime_seconds,
    ar.shift_id, s.name as shift_name,
    ar.status, ar.is_late, ar.is_early_leave
FROM attendance_records ar
JOIN users u ON ar.user_id = u.id
LEFT JOIN shifts s ON ar.shift_id = s.id
WHERE ar.check_in_at >= ?
  AND ar.check_in_at < ?
  AND (? = 0 OR ar.user_id = ?)
ORDER BY ar.user_id, ar.check_in_at
`

type ExportTimesheetForPeriodParams struct {
	CheckInAt   time.Time   `json:"check_in_at"`
	CheckInAt_2 time.Time   `json:"check_in_at_2"`
	Column3     interface{} `json:"column_3"`
	UserID      uint64      `json:"user_id"`
}

type ExportTimesheetForPeriodRow struct {
	ID              uint64                  `json:"id"`
	UserID          uint64                  `json:"user_id"`
	Email           string                  `json:"email"`
	FirstName       string                  `json:"first_name"`
	LastName        string                  `json:"last_name"`
	WorkDate        time.Time               `json:"work_date"`
	CheckInAt       time.Time               `json:"check_in_at"`
	CheckOutAt      sql.NullTime            `json:"check_out_at"`
	DurationSeconds sql.NullInt32           `json:"duration_seconds"`
	OvertimeSeconds sql.NullInt32           `json:"overtime_seconds"`
	ShiftID         sql.NullInt64           `json:"shift_id"`
	ShiftName       sql.NullString          `json:"shift_name"`
	Status          AttendanceRecordsStatus `json:"status"`
	IsLate          bool                    `json:"is_late"`
	IsEarlyLeave    bool                    `json:"is_early_leave"`
}

func (q *Queries) ExportTimesheetForPeriod(ctx context.Context, arg ExportTimesheetForPeriodParams) ([]ExportTimesheetForPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, exportTimesheetForPeriod,
		arg.CheckInAt,
		arg.CheckInAt_2,
		arg.Column3,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExportTimesheetForPeriodRow{}
	for rows.Next() {
		var i ExportTimesheetForPeriodRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.WorkDate,
			&i.CheckInAt,
			&i.CheckOutAt,
			&i.DurationSeconds,
			&i.OvertimeSeconds,
			&i.ShiftID,
			&i.ShiftName,
			&i.Status,
			&i.IsLate,
			&i.IsEarlyLeave,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceByID = `-- name: GetAttendanceByID :one
SELECT id, user_id, shift_id, check_in_at, check_out_at, duration_seconds, 
    overtime_seconds, status, check_in_lat, check_in_lng, check_out_lat, check_out_lng,
    client_check_in_at, client_check_out_at, is_late, is_early_leave, created_at, updated_at
FROM attendance_records
WHERE id = ? LIMIT 1
`

func (q *Queries) GetAttendanceByID(ctx context.Context, id uint64) (AttendanceRecord, error) {
	row := q.db.QueryRowContext(ctx, getAttendanceByID, id)
	var i AttendanceRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ShiftID,
		&i.CheckInAt,
		&i.CheckOutAt,
		&i.DurationSeconds,
		&i.OvertimeSeconds,
		&i.Status,
		&i.CheckInLat,
		&i.CheckInLng,
		&i.CheckOutLat,
		&i.CheckOutLng,
		&i.ClientCheckInAt,
		&i.ClientCheckOutAt,
		&i.IsLate,
		&i.IsEarlyLeave,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeeShiftForDate = `-- name: GetEmployeeShiftForDate :one
SELECT es.id, es.user_id, es.shift_id, es.effective_date, es.end_date,
    s.name, s.start_time, s.end_time, s.break_minutes
FROM employee_shifts es
JOIN shifts s ON es.shift_id = s.id
WHERE es.user_id = ?
  AND es.effective_date <= ?
  AND (es.end_date IS NULL OR es.end_date >= ?)
ORDER BY es.effective_date DESC
LIMIT 1
`

type GetEmployeeShiftForDateParams struct {
	UserID        uint64       `json:"user_id"`
	EffectiveDate time.Time    `json:"effective_date"`
	EndDate       sql.NullTime `json:"end_date"`
}

type GetEmployeeShiftForDateRow struct {
	ID            uint64       `json:"id"`
	UserID        uint64       `json:"user_id"`
	ShiftID       uint64       `json:"shift_id"`
	EffectiveDate time.Time    `json:"effective_date"`
	EndDate       sql.NullTime `json:"end_date"`
	Name          string       `json:"name"`
	StartTime     time.Time    `json:"start_time"`
	EndTime       time.Time    `json:"end_time"`
	BreakMinutes  uint32       `json:"break_minutes"`
}

func (q *Queries) GetEmployeeShiftForDate(ctx context.Context, arg GetEmployeeShiftForDateParams) (GetEmployeeShiftForDateRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeShiftForDate, arg.UserID, arg.EffectiveDate, arg.EndDate)
	var i GetEmployeeShiftForDateRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ShiftID,
		&i.EffectiveDate,
		&i.EndDate,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
		&i.BreakMinutes,
	)
	return i, err
}

const getHolidayByDate = `-- name: GetHolidayByDate :one
SELECT id, name, date, is_paid, description, created_at, updated_at
FROM holidays
WHERE date = ? LIMIT 1
`

func (q *Queries) GetHolidayByDate(ctx context.Context, date time.Time) (Holiday, error) {
	row := q.db.QueryRowContext(ctx, getHolidayByDate, date)
	var i Holiday
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Date,
		&i.IsPaid,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeaveBalance = `-- name: GetLeaveBalance :one

SELECT id, user_id, leave_type, accrued_days, used_days, carryover_days, year
FROM leave_accruals
WHERE user_id = ? AND leave_type = ? AND year = ?
LIMIT 1
`

type GetLeaveBalanceParams struct {
	UserID    uint64                 `json:"user_id"`
	LeaveType LeaveAccrualsLeaveType `json:"leave_type"`
	Year      uint32                 `json:"year"`
}

type GetLeaveBalanceRow struct {
	ID            uint64                 `json:"id"`
	UserID        uint64                 `json:"user_id"`
	LeaveType     LeaveAccrualsLeaveType `json:"leave_type"`
	AccruedDays   string                 `json:"accrued_days"`
	UsedDays      string                 `json:"used_days"`
	CarryoverDays string                 `json:"carryover_days"`
	Year          uint32                 `json:"year"`
}

// Leave Accruals
func (q *Queries) GetLeaveBalance(ctx context.Context, arg GetLeaveBalanceParams) (GetLeaveBalanceRow, error) {
	row := q.db.QueryRowContext(ctx, getLeaveBalance, arg.UserID, arg.LeaveType, arg.Year)
	var i GetLeaveBalanceRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LeaveType,
		&i.AccruedDays,
		&i.UsedDays,
		&i.CarryoverDays,
		&i.Year,
	)
	return i, err
}

const getOpenAttendanceForUser = `-- name: GetOpenAttendanceForUser :one
SELECT id, user_id, shift_id, check_in_at, check_out_at, duration_seconds,
    overtime_seconds, status, check_in_lat, check_in_lng, check_out_lat, check_out_lng,
    client_check_in_at, client_check_out_at, is_late, is_early_leave, created_at, updated_at
FROM attendance_records
WHERE user_id = ? AND check_out_at IS NULL
ORDER BY check_in_at DESC
LIMIT 1 FOR UPDATE
`

func (q *Queries) GetOpenAttendanceForUser(ctx context.Context, userID uint64) (AttendanceRecord, error) {
	row := q.db.QueryRowContext(ctx, getOpenAttendanceForUser, userID)
	var i AttendanceRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ShiftID,
		&i.CheckInAt,
		&i.CheckOutAt,
		&i.DurationSeconds,
		&i.OvertimeSeconds,
		&i.Status,
		&i.CheckInLat,
		&i.CheckInLng,
		&i.CheckOutLat,
		&i.CheckOutLng,
		&i.ClientCheckInAt,
		&i.ClientCheckOutAt,
		&i.IsLate,
		&i.IsEarlyLeave,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShift = `-- name: GetShift :one
SELECT id, name, start_time, end_time, break_minutes, is_active, created_at, updated_at
FROM shifts
WHERE id = ? LIMIT 1
`

func (q *Queries) GetShift(ctx context.Context, id uint64) (Shift, error) {
	row := q.db.QueryRowContext(ctx, getShift, id)
	var i Shift
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
		&i.BreakMinutes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTimeOffByID = `-- name: GetTimeOffByID :one
SELECT id, user_id, leave_type, start_date, end_date, days_count, reason,
    status, reviewed_by, reviewed_at, review_note, created_at, updated_at
FROM time_off_requests
WHERE id = ? LIMIT 1
`

func (q *Queries) GetTimeOffByID(ctx context.Context, id uint64) (TimeOffRequest, error) {
	row := q.db.QueryRowContext(ctx, getTimeOffByID, id)
	var i TimeOffRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LeaveType,
		&i.StartDate,
		&i.EndDate,
		&i.DaysCount,
		&i.Reason,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNote,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAttendance = `-- name: ListAttendance :many
SELECT id, user_id, shift_id, check_in_at, check_out_at, duration_seconds,
    overtime_seconds, status, is_late, is_early_leave, created_at, updated_at
FROM attendance_records
WHERE (? = 0 OR user_id = ?)
  AND (? IS NULL OR check_in_at >= ?)
  AND (? IS NULL OR check_in_at <= ?)
  AND (? = '' OR status = ?)
  AND (? = 0 OR shift_id = ?)
ORDER BY check_in_at DESC
LIMIT ? OFFSET ?
`

type ListAttendanceParams struct {
	Column1     interface{}             `json:"column_1"`
	UserID      uint64                  `json:"user_id"`
	Column3     interface{}             `json:"column_3"`
	CheckInAt   time.Time               `json:"check_in_at"`
	Column5     interface{}             `json:"column_5"`
	CheckInAt_2 time.Time               `json:"check_in_at_2"`
	Column7     interface{}             `json:"column_7"`
	Status      AttendanceRecordsStatus `json:"status"`
	Column9     interface{}             `json:"column_9"`
	ShiftID     sql.NullInt64           `json:"shift_id"`
	Limit       int32                   `json:"limit"`
	Offset      int32                   `json:"offset"`
}

type ListAttendanceRow struct {
	ID              uint64                  `json:"id"`
	UserID          uint64                  `json:"user_id"`
	ShiftID         sql.NullInt64           `json:"shift_id"`
	CheckInAt       time.Time               `json:"check_in_at"`
	CheckOutAt      sql.NullTime            `json:"check_out_at"`
	DurationSeconds sql.NullInt32           `json:"duration_seconds"`
	OvertimeSeconds sql.NullInt32           `json:"overtime_seconds"`
	Status          AttendanceRecordsStatus `json:"status"`
	IsLate          bool                    `json:"is_late"`
	IsEarlyLeave    bool                    `json:"is_early_leave"`
	CreatedAt       time.Time               `json:"created_at"`
	UpdatedAt       time.Time               `json:"updated_at"`
}

func (q *Queries) ListAttendance(ctx context.Context, arg ListAttendanceParams) ([]ListAttendanceRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttendance,
		arg.Column1,
		arg.UserID,
		arg.Column3,
		arg.CheckInAt,
		arg.Column5,
		arg.CheckInAt_2,
		arg.Column7,
		arg.Status,
		arg.Column9,
		arg.ShiftID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAttendanceRow{}
	for rows.Next() {
		var i ListAttendanceRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ShiftID,
			&i.CheckInAt,
			&i.CheckOutAt,
			&i.DurationSeconds,
			&i.OvertimeSeconds,
			&i.Status,
			&i.IsLate,
			&i.IsEarlyLeave,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttendanceExceptions = `-- name: ListAttendanceExceptions :many
SELECT id, attendance_id, exception_type, severity, auto_flagged,
    resolved, resolved_by, resolved_at, created_at
FROM attendance_exceptions
WHERE attendance_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListAttendanceExceptions(ctx context.Context, attendanceID uint64) ([]AttendanceException, error) {
	rows, err := q.db.QueryContext(ctx, listAttendanceExceptions, attendanceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AttendanceException{}
	for rows.Next() {
		var i AttendanceException
		if err := rows.Scan(
			&i.ID,
			&i.AttendanceID,
			&i.ExceptionType,
			&i.Severity,
			&i.AutoFlagged,
			&i.Resolved,
			&i.ResolvedBy,
			&i.ResolvedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttendanceNotes = `-- name: ListAttendanceNotes :many
SELECT an.id, an.attendance_id, an.added_by, an.note, an.created_at,
    u.first_name, u.last_name
FROM attendance_notes an
JOIN users u ON an.added_by = u.id
WHERE an.attendance_id = ?
ORDER BY an.created_at DESC
`

type ListAttendanceNotesRow struct {
	ID           uint64    `json:"id"`
	AttendanceID uint64    `json:"attendance_id"`
	AddedBy      uint64    `json:"added_by"`
	Note         string    `json:"note"`
	CreatedAt    time.Time `json:"created_at"`
	FirstName    string    `json:"first_name"`
	LastName     string    `json:"last_name"`
}

func (q *Queries) ListAttendanceNotes(ctx context.Context, attendanceID uint64) ([]ListAttendanceNotesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttendanceNotes, attendanceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAttendanceNotesRow{}
	for rows.Next() {
		var i ListAttendanceNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.AttendanceID,
			&i.AddedBy,
			&i.Note,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHolidays = `-- name: ListHolidays :many
SELECT id, name, date, is_paid, description, created_at, updated_at
FROM holidays
WHERE (? IS NULL OR date >= ?)
  AND (? IS NULL OR date <= ?)
ORDER BY date
`

type ListHolidaysParams struct {
	Column1 interface{} `json:"column_1"`
	Date    time.Time   `json:"date"`
	Column3 interface{} `json:"column_3"`
	Date_2  time.Time   `json:"date_2"`
}

func (q *Queries) ListHolidays(ctx context.Context, arg ListHolidaysParams) ([]Holiday, error) {
	rows, err := q.db.QueryContext(ctx, listHolidays,
		arg.Column1,
		arg.Date,
		arg.Column3,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Holiday{}
	for rows.Next() {
		var i Holiday
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Date,
			&i.IsPaid,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShifts = `-- name: ListShifts :many
SELECT id, name, start_time, end_time, break_minutes, is_active, created_at, updated_at
FROM shifts
WHERE is_active = TRUE
ORDER BY name
`

func (q *Queries) ListShifts(ctx context.Context) ([]Shift, error) {
	rows, err := q.db.QueryContext(ctx, listShifts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Shift{}
	for rows.Next() {
		var i Shift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
			&i.BreakMinutes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeOffForManager = `-- name: ListTimeOffForManager :many
SELECT tor.id, tor.user_id, tor.leave_type, tor.start_date, tor.end_date,
    tor.days_count, tor.reason, tor.status, tor.reviewed_by, tor.reviewed_at,
    tor.review_note, tor.created_at, tor.updated_at,
    u.first_name, u.last_name, u.email
FROM time_off_requests tor
JOIN users u ON tor.user_id = u.id
WHERE (? = '' OR tor.status = ?)
  AND (? IS NULL OR tor.start_date >= ?)
  AND (? IS NULL OR tor.end_date <= ?)
ORDER BY tor.created_at DESC
LIMIT ? OFFSET ?
`

type ListTimeOffForManagerParams struct {
	Column1   interface{}           `json:"column_1"`
	Status    TimeOffRequestsStatus `json:"status"`
	Column3   interface{}           `json:"column_3"`
	StartDate time.Time             `json:"start_date"`
	Column5   interface{}           `json:"column_5"`
	EndDate   time.Time             `json:"end_date"`
	Limit     int32                 `json:"limit"`
	Offset    int32                 `json:"offset"`
}

type ListTimeOffForManagerRow struct {
	ID         uint64                   `json:"id"`
	UserID     uint64                   `json:"user_id"`
	LeaveType  TimeOffRequestsLeaveType `json:"leave_type"`
	StartDate  time.Time                `json:"start_date"`
	EndDate    time.Time                `json:"end_date"`
	DaysCount  string                   `json:"days_count"`
	Reason     sql.NullString           `json:"reason"`
	Status     TimeOffRequestsStatus    `json:"status"`
	ReviewedBy sql.NullInt64            `json:"reviewed_by"`
	ReviewedAt sql.NullTime             `json:"reviewed_at"`
	ReviewNote sql.NullString           `json:"review_note"`
	CreatedAt  time.Time                `json:"created_at"`
	UpdatedAt  time.Time                `json:"updated_at"`
	FirstName  string                   `json:"first_name"`
	LastName   string                   `json:"last_name"`
	Email      string                   `json:"email"`
}

func (q *Queries) ListTimeOffForManager(ctx context.Context, arg ListTimeOffForManagerParams) ([]ListTimeOffForManagerRow, error) {
	rows, err := q.db.QueryContext(ctx, listTimeOffForManager,
		arg.Column1,
		arg.Status,
		arg.Column3,
		arg.StartDate,
		arg.Column5,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTimeOffForManagerRow{}
	for rows.Next() {
		var i ListTimeOffForManagerRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LeaveType,
			&i.StartDate,
			&i.EndDate,
			&i.DaysCount,
			&i.Reason,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNote,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTimeOff = `-- name: ListUserTimeOff :many
SELECT id, user_id, leave_type, start_date, end_date, days_count, reason,
    status, reviewed_by, reviewed_at, review_note, created_at, updated_at
FROM time_off_requests
WHERE user_id = ?
  AND (? = '' OR status = ?)
ORDER BY start_date DESC
LIMIT ? OFFSET ?
`

type ListUserTimeOffParams struct {
	UserID  uint64                `json:"user_id"`
	Column2 interface{}           `json:"column_2"`
	Status  TimeOffRequestsStatus `json:"status"`
	Limit   int32                 `json:"limit"`
	Offset  int32                 `json:"offset"`
}

func (q *Queries) ListUserTimeOff(ctx context.Context, arg ListUserTimeOffParams) ([]TimeOffRequest, error) {
	rows, err := q.db.QueryContext(ctx, listUserTimeOff,
		arg.UserID,
		arg.Column2,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimeOffRequest{}
	for rows.Next() {
		var i TimeOffRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LeaveType,
			&i.StartDate,
			&i.EndDate,
			&i.DaysCount,
			&i.Reason,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectTimeOff = `-- name: RejectTimeOff :exec
UPDATE time_off_requests
SET status = 'rejected', reviewed_by = ?, reviewed_at = NOW(),
    review_note = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type RejectTimeOffParams struct {
	ReviewedBy sql.NullInt64  `json:"reviewed_by"`
	ReviewNote sql.NullString `json:"review_note"`
	ID         uint64         `json:"id"`
}

func (q *Queries) RejectTimeOff(ctx context.Context, arg RejectTimeOffParams) error {
	_, err := q.db.ExecContext(ctx, rejectTimeOff, arg.ReviewedBy, arg.ReviewNote, arg.ID)
	return err
}

const releaseLock = `-- name: ReleaseLock :exec
SELECT RELEASE_LOCK(?)
`

func (q *Queries) ReleaseLock(ctx context.Context, releaseLOCK string) error {
	_, err := q.db.ExecContext(ctx, releaseLock, releaseLOCK)
	return err
}

const resolveException = `-- name: ResolveException :exec
UPDATE attendance_exceptions
SET resolved = TRUE, resolved_by = ?, resolved_at = NOW()
WHERE id = ?
`

type ResolveExceptionParams struct {
	ResolvedBy sql.NullInt64 `json:"resolved_by"`
	ID         uint64        `json:"id"`
}

func (q *Queries) ResolveException(ctx context.Context, arg ResolveExceptionParams) error {
	_, err := q.db.ExecContext(ctx, resolveException, arg.ResolvedBy, arg.ID)
	return err
}

const updateAttendanceManual = `-- name: UpdateAttendanceManual :exec
UPDATE attendance_records
SET check_in_at = ?, check_out_at = ?, duration_seconds = ?,
    overtime_seconds = ?, status = 'manual', updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateAttendanceManualParams struct {
	CheckInAt       time.Time     `json:"check_in_at"`
	CheckOutAt      sql.NullTime  `json:"check_out_at"`
	DurationSeconds sql.NullInt32 `json:"duration_seconds"`
	OvertimeSeconds sql.NullInt32 `json:"overtime_seconds"`
	ID              uint64        `json:"id"`
}

func (q *Queries) UpdateAttendanceManual(ctx context.Context, arg UpdateAttendanceManualParams) error {
	_, err := q.db.ExecContext(ctx, updateAttendanceManual,
		arg.CheckInAt,
		arg.CheckOutAt,
		arg.DurationSeconds,
		arg.OvertimeSeconds,
		arg.ID,
	)
	return err
}

const upsertLeaveAccrual = `-- name: UpsertLeaveAccrual :exec
INSERT INTO leave_accruals (user_id, leave_type, accrued_days, used_days, carryover_days, year)
VALUES (?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    accrued_days = VALUES(accrued_days),
    used_days = VALUES(used_days),
    carryover_days = VALUES(carryover_days),
    updated_at = CURRENT_TIMESTAMP
`

type UpsertLeaveAccrualParams struct {
	UserID        uint64                 `json:"user_id"`
	LeaveType     LeaveAccrualsLeaveType `json:"leave_type"`
	AccruedDays   string                 `json:"accrued_days"`
	UsedDays      string                 `json:"used_days"`
	CarryoverDays string                 `json:"carryover_days"`
	Year          uint32                 `json:"year"`
}

func (q *Queries) UpsertLeaveAccrual(ctx context.Context, arg UpsertLeaveAccrualParams) error {
	_, err := q.db.ExecContext(ctx, upsertLeaveAccrual,
		arg.UserID,
		arg.LeaveType,
		arg.AccruedDays,
		arg.UsedDays,
		arg.CarryoverDays,
		arg.Year,
	)
	return err
}
